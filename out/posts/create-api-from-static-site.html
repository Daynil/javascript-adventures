<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preload" href="/_next/static/css/c2f986cc7db23e9f9560.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2f986cc7db23e9f9560.css" data-n-g=""/><link rel="preload" href="/_next/static/css/9acf7bc8c7ab2820f562.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9acf7bc8c7ab2820f562.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-c03b5bd9cab9af413ee9.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" as="script"/><link rel="preload" href="/_next/static/chunks/3a4420f2.bca366718f045dbe8189.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.fae3faba8f8bd34b5e08.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-be96f0ea7c84f952feb5.js" as="script"/><link rel="preload" href="/_next/static/chunks/49fdb156c9f06797842462c7c8894acb798ce899.cb877f7e0fcd4b00a731.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-3d9761e151184b59a336.js" as="script"/></head><body><div id="__next"><div class=""><div class="min-h-screen dk:bg-gray-900 transition duration-200 ease-in-out border-t-4 border-dblue-500"><header class="relative max-w-6xl mx-auto px-6 lg:px-8 text-xl mt-3"><div class="flex items-center justify-between md:h-16"><div class="w-full justify-between flex flex-col md:flex-row md:items-center"><div class="flex justify-between"><span class="flex flex-row items-center"><img src="/images/logo-large.png" alt="Javascript Adventures logo"/><span class="ml-2 hidden sm:inline-block" style="font-family:PT Mono, monospace"> <!-- -->Quests In Code</span></span><div class="absolute right-0 top-0 mt-2 mr-5 flex md:hidden"><button class="transition duration-200 ease-in-out inline-flex items-center justify-center p-2 rounded-md text-gray-900 dk:text-gray-100 hover:text-dblue-500 dk-hover:text-dblue-500 focus:outline-none focus:text-white"><svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24"><path class="inline-flex " stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path><path class="inline-flex hidden" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div></div><div class="hidden md:block"><div class="ml-10 flex items-baseline"><a class="navClassName" href="/posts">Posts</a><a class="navClassName" href="/topics">Topics</a><a href="/about">About</a><button class="transition duration-200 ease-in-out ml-4 px-3 py-2 text-xl font-medium text-gray-900 border-b-2 border-transparent dk:text-gray-100 dk-hover:text-dblue-400 hover:text-dblue-500 hover:text-dblue-500 focus:outline-none self-center hover:border-transparent"><svg aria-hidden="true" focusable="false" data-prefix="fad" data-icon="moon-stars" class="w-8" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><g class="fa-group"><path fill="currentColor" d="M320 32L304 0l-16 32-32 16 32 16 16 32 16-32 32-16zm138.7 149.3L432 128l-26.7 53.3L352 208l53.3 26.7L432 288l26.7-53.3L512 208z" opacity="0.4"></path><path fill="currentColor" d="M332.2 426.4c8.1-1.6 13.9 8 8.6 14.5a191.18 191.18 0 0 1-149 71.1C85.8 512 0 426 0 320c0-120 108.7-210.6 227-188.8 8.2 1.6 10.1 12.6 2.8 16.7a150.3 150.3 0 0 0-76.1 130.8c0 94 85.4 165.4 178.5 147.7z"></path></g></svg></button></div></div><div class="flex absolute z-50 inset-0 -mt-3 justify-center w-full h-screen text-center md:hidden hidden" style="background-color:hsla(215, 41%, 28%, 97%)"><button class="transition duration-200 ease-in-out absolute right-0 top-0 mt-5 mr-5 inline-flex items-center justify-center p-2 rounded-md text-gray-100 hover:text-dblue-500 focus:outline-none focus:text-white"><svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24"><path class="inline-flex " stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path><path class="inline-flex hidden" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button><div class="flex flex-col justify-center"><a class="mobileNavClassName" href="/posts">Posts</a><a class="transition duration-200 ease-in-out md:ml-4 mt-2 md:mt-0 px-3 py-2 text-xl font-medium text-gray-100 border-b-2 border-transparent hover:text-dblue-500 hover:border-dblue-500 focus:outline-none" href="/topics">Topics</a><a class="transition duration-200 ease-in-out md:ml-4 mt-2 md:mt-0 px-3 py-2 text-xl font-medium text-gray-100 border-b-2 border-transparent hover:text-dblue-500 hover:border-dblue-500 focus:outline-none" href="/about">About</a><button class="transition duration-200 ease-in-out mt-2 px-3 py-2 text-xl font-medium border-b-2 border-transparent text-gray-100 hover:text-dblue-400 focus:outline-none self-center hover:border-transparent block"><svg aria-hidden="true" focusable="false" data-prefix="fad" data-icon="moon-stars" class="w-8" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><g class="fa-group"><path fill="currentColor" d="M320 32L304 0l-16 32-32 16 32 16 16 32 16-32 32-16zm138.7 149.3L432 128l-26.7 53.3L352 208l53.3 26.7L432 288l26.7-53.3L512 208z" opacity="0.4"></path><path fill="currentColor" d="M332.2 426.4c8.1-1.6 13.9 8 8.6 14.5a191.18 191.18 0 0 1-149 71.1C85.8 512 0 426 0 320c0-120 108.7-210.6 227-188.8 8.2 1.6 10.1 12.6 2.8 16.7a150.3 150.3 0 0 0-76.1 130.8c0 94 85.4 165.4 178.5 147.7z"></path></g></svg></button></div></div></div></div></header><div class="m-auto text-gray-900 dk:text-gray-300 text-lg px-6 md:max-w-3xl transition duration-200 ease-in-out"><main><div></div><div class="mt-24"><div class="text-center"><div class="flex flex-wrap justify-center"><span class="py-1 px-4 ml-4 text-sm font-semibold tracking-widest rounded-full cursor-pointer transition duration-200 ease-in-out bg-dblue-100 text-dblue-700 hover:bg-dblue-200 dk:bg-blue-900 dk:text-dblue-100 dk-hover:bg-blue-700">JavaScript</span><span class="py-1 px-4 ml-4 text-sm font-semibold tracking-widest rounded-full cursor-pointer transition duration-200 ease-in-out bg-dblue-100 text-dblue-700 hover:bg-dblue-200 dk:bg-blue-900 dk:text-dblue-100 dk-hover:bg-blue-700">Gatsby</span></div><h1 class="my-2">Create an API from your Static Site</h1><div class="mb-8 text-gray-700 dk:text-gray-500 flex justify-center flex-col sm:flex-row sm:text-center"><span class="mr-2">2020-07-22<!-- --> <span class="hidden sm:inline-block">‚Ä¢</span> </span><span class="flex items-center justify-center"><span class="flex mr-2"><img src="/images/heart.png" alt="Pixel heart" style="height:24px;image-rendering:pixelated" class=""/><img src="/images/heart.png" alt="Pixel heart" style="height:24px;image-rendering:pixelated" class="ml-1"/><img src="/images/heart.png" alt="Pixel heart" style="height:24px;image-rendering:pixelated" class="ml-1"/></span> <!-- -->3<!-- --> minute read</span></div></div><div class="w-full"></div><div class="mt-20"><span><p>Normally you can&#x27;t publicly expose structured data from a static site via an <a href="https://en.wikipedia.org/wiki/Application_programming_interface">API (Application Programming Interface)</a> because you don&#x27;t control the server (assuming you&#x27;re taking advantage of an excellent <a href="https://www.netlify.com/jamstack/">static site CDN like Netlify</a>), so you can&#x27;t build an API route to access it.</p><p>But what if there was a way to have your static site cake, and eat it too? üç∞ Let&#x27;s create a way to access some structured content from your static site without having to host your own server or use a hosted CMS!</p><h2>What&#x27;s the Point?</h2><p>You may, rightfully, be wondering why you would even bother doing something like this. The point of a static site is to allow pages to be loaded very quickly and cheaply from an edge-hosted CDN, without needing to maintain any servers.</p><p>But what if you have other sites that want to access the data from your site? Usually, if you have lots of complex data or have multiple contributors, you&#x27;d already be using a CMS like <a href="https://www.contentful.com/">Contentful</a>, or perhaps <a href="https://developer.wordpress.org/rest-api/">headless WordPress</a>, in which case you already have an API. But if you&#x27;re building something simple, you can save yourself some complexity by just using local files to store your content.</p><p>If you have your own server to serve your static site, then you can just add an API route which serves the data however you need it. But to me, that defeats the purpose of the simplicity static sites can provide. It&#x27;s nice to avoid servers until you actually really need them, right?!</p><p>For this blog, I currently use markdown files to stash my posts right in my <a href="https://github.com/Daynil/quests-in-code/tree/master/src/content/posts">github repository</a>. Whenever I add a post, Gatsby builds the blog posts into pages, and everything gets pushed and updated on my Netlify account.</p><p>However, I wanted to show a list of information about my blog posts from this site on my <a href="https://dlibin.net/posts/">personal website</a> as well. So how do we access just the metadata of each post on one website from another?</p><p>Typically, if a website doesn&#x27;t have an API, you&#x27;d be stuck with web scraping, an inefficient and error-prone way of getting information from a website at the best of times, but sometimes it&#x27;s all we&#x27;ve got. But we can do better!</p><h2>Static Site vs. Server API</h2><p>I like to think of static site generators like <a href="https://joshwcomeau.com/gatsby/a-static-future/">compile time servers</a>. Once you wrap your head around this concept, you realize that it&#x27;s not a great conceptual leap between a traditional Node server and the Node APIs that Gatsby uses (or <a href="https://www.staticgen.com/">any other static site generator</a> for that matter).</p><p>So with that perspective in mind, let&#x27;s consider with a framework that may be more familiar. How would we approach this if we had our own server?</p><p>One good way to do it might be to grab all of your post&#x27;s metadata, bundle it into JSON, then expose it via a REST API route. For example, if you hit <code>MyBlogAPI.com/posts</code> with a <code>GET</code> request, we could send over the list of all posts in the body of the response as JSON.</p><p>So how would you do this with Gatsby? As it turns out, just about the exact same way! There are two key differences, however.</p><h2>Generate Structured Metadata at Build Time</h2><p>First, instead of dynamically looking up all posts whenever the API is hit, then sending a response, we can take advantage of the build time efficiency of creating a JSON metadata file for all of our posts just once and allowing our CDN to cache it to the edge, whenever we publish a new post.</p><p>Second, the <code>GET</code> request will no longer go to any separate &quot;API&quot;, per se. Instead, we can just save the JSON file in the root public build folder that Gatsby generates when our site is being built, and you can now simply access it by hitting your website&#x27;s base url plus the name of the JSON file! <code>MyGatsbyBlog.com/PostsMetadata.json</code></p><p>Gatsby exposes its build time Node API in the <code>gatsby-node.js</code> file, so let&#x27;s look at what we need for this to work.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-built_in">exports</span>.createPages = <span class="hljs-keyword">async</span> ({ graphql, actions }) =&gt; {
  <span class="hljs-keyword">const</span> { createPage } = actions;

  <span class="hljs-keyword">const</span> mdxPages = <span class="hljs-keyword">await</span> graphql(<span class="hljs-string">`
    query AllMdxPages {
      allMdx(sort: { fields: [frontmatter___date], order: DESC }) {
        edges {
          node {
            excerpt
            timeToRead
            frontmatter {
              date(formatString: &quot;MMMM DD, YYYY&quot;)
              description
              title
              tags
            }
            fields {
              slug
            }
          }
        }
      }
    }
  `</span>);

  <span class="hljs-comment">// Create a page for each post</span>
  <span class="hljs-comment">// Also stash metadata about each post in a JSON file for use by personal site post index</span>
  <span class="hljs-keyword">const</span> posts = mdxPages.data.allMdx.edges;

  <span class="hljs-keyword">let</span> postsMetadata = [];

  posts.forEach(<span class="hljs-function">(<span class="hljs-params">post, index</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> previous = index === posts.length - <span class="hljs-number">1</span> ? <span class="hljs-literal">null</span> : posts[index + <span class="hljs-number">1</span>].node;
    <span class="hljs-keyword">const</span> next = index === <span class="hljs-number">0</span> ? <span class="hljs-literal">null</span> : posts[index - <span class="hljs-number">1</span>].node;
    createPage({
      <span class="hljs-attr">path</span>: post.node.fields.slug,
      <span class="hljs-attr">component</span>: path.resolve(<span class="hljs-string">&#x27;./src/components/blog-post/blog-post.tsx&#x27;</span>),
      <span class="hljs-attr">context</span>: {
        <span class="hljs-attr">slug</span>: post.node.fields.slug,
        <span class="hljs-attr">featuredImage</span>: <span class="hljs-string">`<span class="hljs-subst">${post.node.fields.slug}</span>featuredImage.png/`</span>,
        previous,
        next
      }
    });

    postsMetadata.push({
      <span class="hljs-attr">excerpt</span>: post.node.excerpt,
      <span class="hljs-attr">timeToRead</span>: post.node.timeToRead,
      <span class="hljs-attr">date</span>: post.node.frontmatter.date,
      <span class="hljs-attr">description</span>: post.node.frontmatter.description,
      <span class="hljs-attr">title</span>: post.node.frontmatter.title,
      <span class="hljs-attr">tags</span>: post.node.frontmatter.tags,
      <span class="hljs-attr">slug</span>: post.node.fields.slug
    });
  });

  fs.writeFileSync(
    <span class="hljs-string">&#x27;./public/postsMetaData.json&#x27;</span>,
    <span class="hljs-built_in">JSON</span>.stringify(postsMetadata)
  );
};
</code></pre><p>In this function, first we&#x27;re querying our GraphQL layer for all the data about our posts. Then, we loop over each post and create a page for it. If you want to understand this part more deeply, I have a post <a href="/posts/gatsby-blog-from-scratch/">diving into the details of the inner workings of Gatsby, GraphQL, and how the build process happens</a>.</p><p>The more relevant bit to this discussion is what we do after we build a page for each post - we create an object with metadata details about the post and add it to an array. Once we&#x27;ve got our full array of metadata about our posts, we use Node&#x27;s <code>writeFileSync</code> function to serialize and write the entire array out into a JSON file, which we put directly into the public build folder for Gatsy.</p><p>That&#x27;s it, we&#x27;re done! Now, any time we rebuild the site with a new post, the metadata file gets updated with that file&#x27;s new JSON data.</p><p>So now, as soon as we hit our blog&#x27;s url and add <code>/postsMetaData.json</code>, we&#x27;ll get a body of just the <a href="https://questsincode.com/postsMetaData.json">raw JSON string</a>.</p><p>Great! All we have to do is jump over to wherever else we want to access this data programmatically and issue a <code>GET</code> request using our HTTP request library of choice.</p><pre><code class="hljs language-javascript">fetch(<span class="hljs-string">&#x27;https://questsincode.com/postsMetaData.json&#x27;</span>)
  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.json())
  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
    <span class="hljs-comment">// Do something creative</span>
  });
</code></pre><p>But wait, I hear you saying already. What about...<a href="https://stackoverflow.com/questions/tagged/cors">CORS</a>?! üò±</p><h2>Addressing the CORS Issue</h2><p>If you&#x27;ve been coding for the web for any length of time, you&#x27;ll likely have run into the dreaded CORS issue from time to time. <a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross-origin resource sharing (CORS)</a> is a security mechanism that prevents making requests to external domains from within the javascript of the domain your requesting code is served from.</p><p>If you had your own server for your static site and created an API route for the metadata, this wouldn&#x27;t be a problem, since they would be on the same domain. If you were using a CMS, CORS would likely already be set up.</p><p>However, in our situation, we&#x27;re making a request from one domain to another within the javascript of our site, so the fetch request will immediately fail with a CORS error.</p><p>If you were running an <a href="https://expressjs.com/en/resources/middleware/cors.html">express server</a>, you might be familiar with allowing cross-origin requests with a bit of configuration.</p><div class="remark-code-title">my-blog-server.js</div><pre><code class="hljs language-javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">var</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);
<span class="hljs-keyword">var</span> app = express();

app.use(cors());
</code></pre><p>However, if we&#x27;re hosting on a CDN like Netlify, we don&#x27;t have access to the code that serves our site. So I guess we can&#x27;t do this after all? üò¢</p><p>Not so fast! Netlify is pretty awesome, so it provides a <a href="https://docs.netlify.com/configure-builds/common-configurations/">wealth of configuration options</a> available for most use cases you can imagine.</p><p>For our case, we are interested in the <a href="https://docs.netlify.com/configure-builds/file-based-configuration/">file-based configuration options, which are stored in the <code>netlify.toml</code> file</a>. We can allow cross-origin requests right in the toml file. In fact, since we only care about cross-origin requests to the metadata file, we can restrict this option to just that route!</p><div class="remark-code-title">netlify.toml</div><pre><code class="hljs language-text">[[headers]]
  # Define which paths this specific [[headers]] block will cover.
  for = &quot;/postsMetaData.json&quot;
    [headers.values]
    Access-Control-Allow-Origin = &quot;*&quot;
</code></pre><p>If you&#x27;re using Gatsby, make sure to place the <code>netlify.toml</code> file in the <a href="https://www.gatsbyjs.org/docs/static-folder/">root static folder</a> of your site. This basically just tells Gatsby to do nothing to this file at build time except move it to the root public build directory, which is exactly where Netlify expects it.</p><p>Now, if we go back and make our HTTP request for our blog metadata on our other site, we&#x27;ll get the data as expected!</p><h2>Conclusion</h2><p>This example uses Gatsby, but you could do the same with other static site generators. During the step where you would typically generate the site from your local data, hook in with your code to expose any data you need in a structured file like JSON, then link it to a route on your website. Here&#x27;s an example of <a href="https://www.raymondcamden.com/2016/03/01/adding-an-api-to-a-static-site">creating an API for your static Jekyll site</a>.</p><p>If you&#x27;re using something other than Netlify as your CDN host, search their documentation for configuration instructions. CORS is a common enough configuration for most hosts to allow adjustment. For example, <a href="https://firebase.google.com/docs/hosting/full-config#headers">Firebase allows you to define CORS behavior in your <code>firebase.json</code> file</a>.</p><p>It requires a bit of a perspective shift, but thinking this way unlocks many new capabilities for your static site generator!</p></span></div><a href="https://twitter.com/share?url=https://questsincode.com/posts/create-api-from-static-site/&amp;text=‚ÄúCreate an API from your Static Site‚Äù, a post from Danny Libin.&amp;via=Dayn1l" target="_blank" class="flex flex-row mt-12"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="text-dblue-500 hover:text-dblue-300 transition-colors ease-in-out duration-300 w-24" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><span class="ml-4 p-4 bg-dblue-200 dk:bg-dblue-800 text-dblue-800 dk:text-dblue-200 text-2xl rounded-md">Found this article useful? Click to share, discuss and spread the word!! üéâ</span></a><h2>Webmentions (<span class="border-b-2 border-dblue-500 text-gray-900 dk:text-gray-300 dk-hover:text-dblue-500 hover:text-dblue-500 hover:border-transparent transition duration-200 ease-in-out"><a href="https://indieweb.org/Webmention" rel="noopener" target="_blank" class="text-lg border-b-0">‚ùî</a></span>)</h2><div>No comments yet.<!-- --> <span class="border-b-2 border-dblue-500 text-gray-900 dk:text-gray-300 dk-hover:text-dblue-500 hover:text-dblue-500 hover:border-transparent transition duration-200 ease-in-out"><a href="https://twitter.com/share?url=https://questsincode.com/posts/create-api-from-static-site/&amp;text=‚ÄúCreate an API from your Static Site‚Äù, a post from Danny Libin.&amp;via=Dayn1l" rel="noopener" target="_blank">Start the conversation!</a></span> <!-- -->Your post will show up here.</div></div></main><footer class="text-gray-600 mt-32 pb-12">¬© <!-- -->2020<!-- --> Quests In Code. All Rights Reserved. Created by<!-- --> <span class="border-b-2 border-dblue-500 text-gray-900 dk:text-gray-300 dk-hover:text-dblue-500 hover:text-dblue-500 hover:border-transparent transition duration-200 ease-in-out"><a href="https://dlibin.net" rel="noopener" target="_blank">Danny Libin</a></span>.</footer></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Normally you can't publicly expose structured data from a static site via an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Application_programming_interface\"\n  }), \"API (Application Programming Interface)\"), \" because you don't control the server (assuming you're taking advantage of an excellent \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.netlify.com/jamstack/\"\n  }), \"static site CDN like Netlify\"), \"), so you can't build an API route to access it.\"), mdx(\"p\", null, \"But what if there was a way to have your static site cake, and eat it too? \\uD83C\\uDF70 Let's create a way to access some structured content from your static site without having to host your own server or use a hosted CMS!\"), mdx(\"h2\", null, \"What's the Point?\"), mdx(\"p\", null, \"You may, rightfully, be wondering why you would even bother doing something like this. The point of a static site is to allow pages to be loaded very quickly and cheaply from an edge-hosted CDN, without needing to maintain any servers.\"), mdx(\"p\", null, \"But what if you have other sites that want to access the data from your site? Usually, if you have lots of complex data or have multiple contributors, you'd already be using a CMS like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.contentful.com/\"\n  }), \"Contentful\"), \", or perhaps \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.wordpress.org/rest-api/\"\n  }), \"headless WordPress\"), \", in which case you already have an API. But if you're building something simple, you can save yourself some complexity by just using local files to store your content.\"), mdx(\"p\", null, \"If you have your own server to serve your static site, then you can just add an API route which serves the data however you need it. But to me, that defeats the purpose of the simplicity static sites can provide. It's nice to avoid servers until you actually really need them, right?!\"), mdx(\"p\", null, \"For this blog, I currently use markdown files to stash my posts right in my \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/Daynil/quests-in-code/tree/master/src/content/posts\"\n  }), \"github repository\"), \". Whenever I add a post, Gatsby builds the blog posts into pages, and everything gets pushed and updated on my Netlify account.\"), mdx(\"p\", null, \"However, I wanted to show a list of information about my blog posts from this site on my \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://dlibin.net/posts/\"\n  }), \"personal website\"), \" as well. So how do we access just the metadata of each post on one website from another?\"), mdx(\"p\", null, \"Typically, if a website doesn't have an API, you'd be stuck with web scraping, an inefficient and error-prone way of getting information from a website at the best of times, but sometimes it's all we've got. But we can do better!\"), mdx(\"h2\", null, \"Static Site vs. Server API\"), mdx(\"p\", null, \"I like to think of static site generators like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://joshwcomeau.com/gatsby/a-static-future/\"\n  }), \"compile time servers\"), \". Once you wrap your head around this concept, you realize that it's not a great conceptual leap between a traditional Node server and the Node APIs that Gatsby uses (or \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.staticgen.com/\"\n  }), \"any other static site generator\"), \" for that matter).\"), mdx(\"p\", null, \"So with that perspective in mind, let's consider with a framework that may be more familiar. How would we approach this if we had our own server?\"), mdx(\"p\", null, \"One good way to do it might be to grab all of your post's metadata, bundle it into JSON, then expose it via a REST API route. For example, if you hit \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyBlogAPI.com/posts\"), \" with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET\"), \" request, we could send over the list of all posts in the body of the response as JSON.\"), mdx(\"p\", null, \"So how would you do this with Gatsby? As it turns out, just about the exact same way! There are two key differences, however.\"), mdx(\"h2\", null, \"Generate Structured Metadata at Build Time\"), mdx(\"p\", null, \"First, instead of dynamically looking up all posts whenever the API is hit, then sending a response, we can take advantage of the build time efficiency of creating a JSON metadata file for all of our posts just once and allowing our CDN to cache it to the edge, whenever we publish a new post.\"), mdx(\"p\", null, \"Second, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET\"), \" request will no longer go to any separate \\\"API\\\", per se. Instead, we can just save the JSON file in the root public build folder that Gatsby generates when our site is being built, and you can now simply access it by hitting your website's base url plus the name of the JSON file! \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"MyGatsbyBlog.com/PostsMetadata.json\")), mdx(\"p\", null, \"Gatsby exposes its build time Node API in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file, so let's look at what we need for this to work.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" path = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'path'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" fs = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'fs'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".createPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({ graphql, actions }) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createPage } = actions;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" mdxPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"await\"), \" graphql(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\\n    query AllMdxPages {\\n      allMdx(sort: { fields: [frontmatter___date], order: DESC }) {\\n        edges {\\n          node {\\n            excerpt\\n            timeToRead\\n            frontmatter {\\n              date(formatString: \\\"MMMM DD, YYYY\\\")\\n              description\\n              title\\n              tags\\n            }\\n            fields {\\n              slug\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `\"), \");\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// Create a page for each post\"), \"\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// Also stash metadata about each post in a JSON file for use by personal site post index\"), \"\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" posts = mdxPages.data.allMdx.edges;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"let\"), \" postsMetadata = [];\\n\\n  posts.forEach(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"post, index\"), \") =\u003e\"), \" {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" previous = index === posts.length - \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"1\"), \" ? \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-literal\"\n  }), \"null\"), \" : posts[index + \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"1\"), \"].node;\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" next = index === \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"0\"), \" ? \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-literal\"\n  }), \"null\"), \" : posts[index - \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"1\"), \"].node;\\n    createPage({\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": post.node.fields.slug,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"component\"), \": path.resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./src/components/blog-post/blog-post.tsx'\"), \"),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"context\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"slug\"), \": post.node.fields.slug,\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"featuredImage\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${post.node.fields.slug}\"), \"featuredImage.png/`\"), \",\\n        previous,\\n        next\\n      }\\n    });\\n\\n    postsMetadata.push({\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"excerpt\"), \": post.node.excerpt,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"timeToRead\"), \": post.node.timeToRead,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"date\"), \": post.node.frontmatter.date,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"description\"), \": post.node.frontmatter.description,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"title\"), \": post.node.frontmatter.title,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"tags\"), \": post.node.frontmatter.tags,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"slug\"), \": post.node.fields.slug\\n    });\\n  });\\n\\n  fs.writeFileSync(\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./public/postsMetaData.json'\"), \",\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"JSON\"), \".stringify(postsMetadata)\\n  );\\n};\\n\")), mdx(\"p\", null, \"In this function, first we're querying our GraphQL layer for all the data about our posts. Then, we loop over each post and create a page for it. If you want to understand this part more deeply, I have a post \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/posts/gatsby-blog-from-scratch/\"\n  }), \"diving into the details of the inner workings of Gatsby, GraphQL, and how the build process happens\"), \".\"), mdx(\"p\", null, \"The more relevant bit to this discussion is what we do after we build a page for each post - we create an object with metadata details about the post and add it to an array. Once we've got our full array of metadata about our posts, we use Node's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"writeFileSync\"), \" function to serialize and write the entire array out into a JSON file, which we put directly into the public build folder for Gatsy.\"), mdx(\"p\", null, \"That's it, we're done! Now, any time we rebuild the site with a new post, the metadata file gets updated with that file's new JSON data.\"), mdx(\"p\", null, \"So now, as soon as we hit our blog's url and add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/postsMetaData.json\"), \", we'll get a body of just the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://questsincode.com/postsMetaData.json\"\n  }), \"raw JSON string\"), \".\"), mdx(\"p\", null, \"Great! All we have to do is jump over to wherever else we want to access this data programmatically and issue a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GET\"), \" request using our HTTP request library of choice.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), \"fetch(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'https://questsincode.com/postsMetaData.json'\"), \")\\n  .then(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"res\"), \" =\u003e\"), \" res.json())\\n  .then(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"data\"), \" =\u003e\"), \" {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// Do something creative\"), \"\\n  });\\n\")), mdx(\"p\", null, \"But wait, I hear you saying already. What about...\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stackoverflow.com/questions/tagged/cors\"\n  }), \"CORS\"), \"?! \\uD83D\\uDE31\"), mdx(\"h2\", null, \"Addressing the CORS Issue\"), mdx(\"p\", null, \"If you've been coding for the web for any length of time, you'll likely have run into the dreaded CORS issue from time to time. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\"\n  }), \"Cross-origin resource sharing (CORS)\"), \" is a security mechanism that prevents making requests to external domains from within the javascript of the domain your requesting code is served from.\"), mdx(\"p\", null, \"If you had your own server for your static site and created an API route for the metadata, this wouldn't be a problem, since they would be on the same domain. If you were using a CMS, CORS would likely already be set up.\"), mdx(\"p\", null, \"However, in our situation, we're making a request from one domain to another within the javascript of our site, so the fetch request will immediately fail with a CORS error.\"), mdx(\"p\", null, \"If you were running an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://expressjs.com/en/resources/middleware/cors.html\"\n  }), \"express server\"), \", you might be familiar with allowing cross-origin requests with a bit of configuration.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"my-blog-server.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"var\"), \" express = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'express'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"var\"), \" cors = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'cors'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"var\"), \" app = express();\\n\\napp.use(cors());\\n\")), mdx(\"p\", null, \"However, if we're hosting on a CDN like Netlify, we don't have access to the code that serves our site. So I guess we can't do this after all? \\uD83D\\uDE22\"), mdx(\"p\", null, \"Not so fast! Netlify is pretty awesome, so it provides a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.netlify.com/configure-builds/common-configurations/\"\n  }), \"wealth of configuration options\"), \" available for most use cases you can imagine.\"), mdx(\"p\", null, \"For our case, we are interested in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.netlify.com/configure-builds/file-based-configuration/\"\n  }), \"file-based configuration options, which are stored in the \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"netlify.toml\"), \" file\"), \". We can allow cross-origin requests right in the toml file. In fact, since we only care about cross-origin requests to the metadata file, we can restrict this option to just that route!\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"netlify.toml\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-text\"\n  }), \"[[headers]]\\n  # Define which paths this specific [[headers]] block will cover.\\n  for = \\\"/postsMetaData.json\\\"\\n    [headers.values]\\n    Access-Control-Allow-Origin = \\\"*\\\"\\n\")), mdx(\"p\", null, \"If you're using Gatsby, make sure to place the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"netlify.toml\"), \" file in the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gatsbyjs.org/docs/static-folder/\"\n  }), \"root static folder\"), \" of your site. This basically just tells Gatsby to do nothing to this file at build time except move it to the root public build directory, which is exactly where Netlify expects it.\"), mdx(\"p\", null, \"Now, if we go back and make our HTTP request for our blog metadata on our other site, we'll get the data as expected!\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"This example uses Gatsby, but you could do the same with other static site generators. During the step where you would typically generate the site from your local data, hook in with your code to expose any data you need in a structured file like JSON, then link it to a route on your website. Here's an example of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.raymondcamden.com/2016/03/01/adding-an-api-to-a-static-site\"\n  }), \"creating an API for your static Jekyll site\"), \".\"), mdx(\"p\", null, \"If you're using something other than Netlify as your CDN host, search their documentation for configuration instructions. CORS is a common enough configuration for most hosts to allow adjustment. For example, \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://firebase.google.com/docs/hosting/full-config#headers\"\n  }), \"Firebase allows you to define CORS behavior in your \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"firebase.json\"), \" file\"), \".\"), mdx(\"p\", null, \"It requires a bit of a perspective shift, but thinking this way unlocks many new capabilities for your static site generator!\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cp\u003eNormally you can\u0026#x27;t publicly expose structured data from a static site via an \u003ca href=\"https://en.wikipedia.org/wiki/Application_programming_interface\"\u003eAPI (Application Programming Interface)\u003c/a\u003e because you don\u0026#x27;t control the server (assuming you\u0026#x27;re taking advantage of an excellent \u003ca href=\"https://www.netlify.com/jamstack/\"\u003estatic site CDN like Netlify\u003c/a\u003e), so you can\u0026#x27;t build an API route to access it.\u003c/p\u003e\u003cp\u003eBut what if there was a way to have your static site cake, and eat it too? üç∞ Let\u0026#x27;s create a way to access some structured content from your static site without having to host your own server or use a hosted CMS!\u003c/p\u003e\u003ch2\u003eWhat\u0026#x27;s the Point?\u003c/h2\u003e\u003cp\u003eYou may, rightfully, be wondering why you would even bother doing something like this. The point of a static site is to allow pages to be loaded very quickly and cheaply from an edge-hosted CDN, without needing to maintain any servers.\u003c/p\u003e\u003cp\u003eBut what if you have other sites that want to access the data from your site? Usually, if you have lots of complex data or have multiple contributors, you\u0026#x27;d already be using a CMS like \u003ca href=\"https://www.contentful.com/\"\u003eContentful\u003c/a\u003e, or perhaps \u003ca href=\"https://developer.wordpress.org/rest-api/\"\u003eheadless WordPress\u003c/a\u003e, in which case you already have an API. But if you\u0026#x27;re building something simple, you can save yourself some complexity by just using local files to store your content.\u003c/p\u003e\u003cp\u003eIf you have your own server to serve your static site, then you can just add an API route which serves the data however you need it. But to me, that defeats the purpose of the simplicity static sites can provide. It\u0026#x27;s nice to avoid servers until you actually really need them, right?!\u003c/p\u003e\u003cp\u003eFor this blog, I currently use markdown files to stash my posts right in my \u003ca href=\"https://github.com/Daynil/quests-in-code/tree/master/src/content/posts\"\u003egithub repository\u003c/a\u003e. Whenever I add a post, Gatsby builds the blog posts into pages, and everything gets pushed and updated on my Netlify account.\u003c/p\u003e\u003cp\u003eHowever, I wanted to show a list of information about my blog posts from this site on my \u003ca href=\"https://dlibin.net/posts/\"\u003epersonal website\u003c/a\u003e as well. So how do we access just the metadata of each post on one website from another?\u003c/p\u003e\u003cp\u003eTypically, if a website doesn\u0026#x27;t have an API, you\u0026#x27;d be stuck with web scraping, an inefficient and error-prone way of getting information from a website at the best of times, but sometimes it\u0026#x27;s all we\u0026#x27;ve got. But we can do better!\u003c/p\u003e\u003ch2\u003eStatic Site vs. Server API\u003c/h2\u003e\u003cp\u003eI like to think of static site generators like \u003ca href=\"https://joshwcomeau.com/gatsby/a-static-future/\"\u003ecompile time servers\u003c/a\u003e. Once you wrap your head around this concept, you realize that it\u0026#x27;s not a great conceptual leap between a traditional Node server and the Node APIs that Gatsby uses (or \u003ca href=\"https://www.staticgen.com/\"\u003eany other static site generator\u003c/a\u003e for that matter).\u003c/p\u003e\u003cp\u003eSo with that perspective in mind, let\u0026#x27;s consider with a framework that may be more familiar. How would we approach this if we had our own server?\u003c/p\u003e\u003cp\u003eOne good way to do it might be to grab all of your post\u0026#x27;s metadata, bundle it into JSON, then expose it via a REST API route. For example, if you hit \u003ccode\u003eMyBlogAPI.com/posts\u003c/code\u003e with a \u003ccode\u003eGET\u003c/code\u003e request, we could send over the list of all posts in the body of the response as JSON.\u003c/p\u003e\u003cp\u003eSo how would you do this with Gatsby? As it turns out, just about the exact same way! There are two key differences, however.\u003c/p\u003e\u003ch2\u003eGenerate Structured Metadata at Build Time\u003c/h2\u003e\u003cp\u003eFirst, instead of dynamically looking up all posts whenever the API is hit, then sending a response, we can take advantage of the build time efficiency of creating a JSON metadata file for all of our posts just once and allowing our CDN to cache it to the edge, whenever we publish a new post.\u003c/p\u003e\u003cp\u003eSecond, the \u003ccode\u003eGET\u003c/code\u003e request will no longer go to any separate \u0026quot;API\u0026quot;, per se. Instead, we can just save the JSON file in the root public build folder that Gatsby generates when our site is being built, and you can now simply access it by hitting your website\u0026#x27;s base url plus the name of the JSON file! \u003ccode\u003eMyGatsbyBlog.com/PostsMetadata.json\u003c/code\u003e\u003c/p\u003e\u003cp\u003eGatsby exposes its build time Node API in the \u003ccode\u003egatsby-node.js\u003c/code\u003e file, so let\u0026#x27;s look at what we need for this to work.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;path\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;fs\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.createPages = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ graphql, actions }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createPage } = actions;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e mdxPages = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e graphql(\u003cspan class=\"hljs-string\"\u003e`\n    query AllMdxPages {\n      allMdx(sort: { fields: [frontmatter___date], order: DESC }) {\n        edges {\n          node {\n            excerpt\n            timeToRead\n            frontmatter {\n              date(formatString: \u0026quot;MMMM DD, YYYY\u0026quot;)\n              description\n              title\n              tags\n            }\n            fields {\n              slug\n            }\n          }\n        }\n      }\n    }\n  `\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// Create a page for each post\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// Also stash metadata about each post in a JSON file for use by personal site post index\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e posts = mdxPages.data.allMdx.edges;\n\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e postsMetadata = [];\n\n  posts.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003epost, index\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e previous = index === posts.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e : posts[index + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].node;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e next = index === \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e ? \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e : posts[index - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].node;\n    createPage({\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: post.node.fields.slug,\n      \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: path.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/components/blog-post/blog-post.tsx\u0026#x27;\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e: post.node.fields.slug,\n        \u003cspan class=\"hljs-attr\"\u003efeaturedImage\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${post.node.fields.slug}\u003c/span\u003efeaturedImage.png/`\u003c/span\u003e,\n        previous,\n        next\n      }\n    });\n\n    postsMetadata.push({\n      \u003cspan class=\"hljs-attr\"\u003eexcerpt\u003c/span\u003e: post.node.excerpt,\n      \u003cspan class=\"hljs-attr\"\u003etimeToRead\u003c/span\u003e: post.node.timeToRead,\n      \u003cspan class=\"hljs-attr\"\u003edate\u003c/span\u003e: post.node.frontmatter.date,\n      \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: post.node.frontmatter.description,\n      \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: post.node.frontmatter.title,\n      \u003cspan class=\"hljs-attr\"\u003etags\u003c/span\u003e: post.node.frontmatter.tags,\n      \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e: post.node.fields.slug\n    });\n  });\n\n  fs.writeFileSync(\n    \u003cspan class=\"hljs-string\"\u003e\u0026#x27;./public/postsMetaData.json\u0026#x27;\u003c/span\u003e,\n    \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.stringify(postsMetadata)\n  );\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn this function, first we\u0026#x27;re querying our GraphQL layer for all the data about our posts. Then, we loop over each post and create a page for it. If you want to understand this part more deeply, I have a post \u003ca href=\"/posts/gatsby-blog-from-scratch/\"\u003ediving into the details of the inner workings of Gatsby, GraphQL, and how the build process happens\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eThe more relevant bit to this discussion is what we do after we build a page for each post - we create an object with metadata details about the post and add it to an array. Once we\u0026#x27;ve got our full array of metadata about our posts, we use Node\u0026#x27;s \u003ccode\u003ewriteFileSync\u003c/code\u003e function to serialize and write the entire array out into a JSON file, which we put directly into the public build folder for Gatsy.\u003c/p\u003e\u003cp\u003eThat\u0026#x27;s it, we\u0026#x27;re done! Now, any time we rebuild the site with a new post, the metadata file gets updated with that file\u0026#x27;s new JSON data.\u003c/p\u003e\u003cp\u003eSo now, as soon as we hit our blog\u0026#x27;s url and add \u003ccode\u003e/postsMetaData.json\u003c/code\u003e, we\u0026#x27;ll get a body of just the \u003ca href=\"https://questsincode.com/postsMetaData.json\"\u003eraw JSON string\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eGreat! All we have to do is jump over to wherever else we want to access this data programmatically and issue a \u003ccode\u003eGET\u003c/code\u003e request using our HTTP request library of choice.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003efetch(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;https://questsincode.com/postsMetaData.json\u0026#x27;\u003c/span\u003e)\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e res.json())\n  .then(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Do something creative\u003c/span\u003e\n  });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eBut wait, I hear you saying already. What about...\u003ca href=\"https://stackoverflow.com/questions/tagged/cors\"\u003eCORS\u003c/a\u003e?! üò±\u003c/p\u003e\u003ch2\u003eAddressing the CORS Issue\u003c/h2\u003e\u003cp\u003eIf you\u0026#x27;ve been coding for the web for any length of time, you\u0026#x27;ll likely have run into the dreaded CORS issue from time to time. \u003ca href=\"https://en.wikipedia.org/wiki/Cross-origin_resource_sharing\"\u003eCross-origin resource sharing (CORS)\u003c/a\u003e is a security mechanism that prevents making requests to external domains from within the javascript of the domain your requesting code is served from.\u003c/p\u003e\u003cp\u003eIf you had your own server for your static site and created an API route for the metadata, this wouldn\u0026#x27;t be a problem, since they would be on the same domain. If you were using a CMS, CORS would likely already be set up.\u003c/p\u003e\u003cp\u003eHowever, in our situation, we\u0026#x27;re making a request from one domain to another within the javascript of our site, so the fetch request will immediately fail with a CORS error.\u003c/p\u003e\u003cp\u003eIf you were running an \u003ca href=\"https://expressjs.com/en/resources/middleware/cors.html\"\u003eexpress server\u003c/a\u003e, you might be familiar with allowing cross-origin requests with a bit of configuration.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003emy-blog-server.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;express\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e cors = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;cors\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e app = express();\n\napp.use(cors());\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHowever, if we\u0026#x27;re hosting on a CDN like Netlify, we don\u0026#x27;t have access to the code that serves our site. So I guess we can\u0026#x27;t do this after all? üò¢\u003c/p\u003e\u003cp\u003eNot so fast! Netlify is pretty awesome, so it provides a \u003ca href=\"https://docs.netlify.com/configure-builds/common-configurations/\"\u003ewealth of configuration options\u003c/a\u003e available for most use cases you can imagine.\u003c/p\u003e\u003cp\u003eFor our case, we are interested in the \u003ca href=\"https://docs.netlify.com/configure-builds/file-based-configuration/\"\u003efile-based configuration options, which are stored in the \u003ccode\u003enetlify.toml\u003c/code\u003e file\u003c/a\u003e. We can allow cross-origin requests right in the toml file. In fact, since we only care about cross-origin requests to the metadata file, we can restrict this option to just that route!\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003enetlify.toml\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-text\"\u003e[[headers]]\n  # Define which paths this specific [[headers]] block will cover.\n  for = \u0026quot;/postsMetaData.json\u0026quot;\n    [headers.values]\n    Access-Control-Allow-Origin = \u0026quot;*\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you\u0026#x27;re using Gatsby, make sure to place the \u003ccode\u003enetlify.toml\u003c/code\u003e file in the \u003ca href=\"https://www.gatsbyjs.org/docs/static-folder/\"\u003eroot static folder\u003c/a\u003e of your site. This basically just tells Gatsby to do nothing to this file at build time except move it to the root public build directory, which is exactly where Netlify expects it.\u003c/p\u003e\u003cp\u003eNow, if we go back and make our HTTP request for our blog metadata on our other site, we\u0026#x27;ll get the data as expected!\u003c/p\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eThis example uses Gatsby, but you could do the same with other static site generators. During the step where you would typically generate the site from your local data, hook in with your code to expose any data you need in a structured file like JSON, then link it to a route on your website. Here\u0026#x27;s an example of \u003ca href=\"https://www.raymondcamden.com/2016/03/01/adding-an-api-to-a-static-site\"\u003ecreating an API for your static Jekyll site\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIf you\u0026#x27;re using something other than Netlify as your CDN host, search their documentation for configuration instructions. CORS is a common enough configuration for most hosts to allow adjustment. For example, \u003ca href=\"https://firebase.google.com/docs/hosting/full-config#headers\"\u003eFirebase allows you to define CORS behavior in your \u003ccode\u003efirebase.json\u003c/code\u003e file\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIt requires a bit of a perspective shift, but thinking this way unlocks many new capabilities for your static site generator!\u003c/p\u003e","scope":{}},"slug":"create-api-from-static-site","title":"Create an API from your Static Site","tags":["JavaScript","Gatsby"],"date":"2020-07-22","description":"Create an API using data from your static site so you can read data from it in another application without resorting to web scraping."},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"create-api-from-static-site"},"buildId":"g7013D7AffeHbYIMAFrrP","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["meta",{"name":"viewport","content":"width=device-width"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-555defa4e62ba07d4446.js"></script><script src="/_next/static/chunks/main-c03b5bd9cab9af413ee9.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" async=""></script><script src="/_next/static/chunks/3a4420f2.bca366718f045dbe8189.js" async=""></script><script src="/_next/static/chunks/commons.fae3faba8f8bd34b5e08.js" async=""></script><script src="/_next/static/chunks/pages/_app-be96f0ea7c84f952feb5.js" async=""></script><script src="/_next/static/chunks/49fdb156c9f06797842462c7c8894acb798ce899.cb877f7e0fcd4b00a731.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-3d9761e151184b59a336.js" async=""></script><script src="/_next/static/g7013D7AffeHbYIMAFrrP/_buildManifest.js" async=""></script><script src="/_next/static/g7013D7AffeHbYIMAFrrP/_ssgManifest.js" async=""></script></body></html>