<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="preload" href="/_next/static/css/c2f986cc7db23e9f9560.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c2f986cc7db23e9f9560.css" data-n-g=""/><link rel="preload" href="/_next/static/css/9acf7bc8c7ab2820f562.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9acf7bc8c7ab2820f562.css" data-n-g=""/><noscript data-n-css="true"></noscript><link rel="preload" href="/_next/static/chunks/main-c03b5bd9cab9af413ee9.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" as="script"/><link rel="preload" href="/_next/static/chunks/3a4420f2.bca366718f045dbe8189.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.fae3faba8f8bd34b5e08.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-be96f0ea7c84f952feb5.js" as="script"/><link rel="preload" href="/_next/static/chunks/49fdb156c9f06797842462c7c8894acb798ce899.cb877f7e0fcd4b00a731.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bslug%5D-3d9761e151184b59a336.js" as="script"/></head><body><div id="__next"><div class=""><div class="min-h-screen dk:bg-gray-900 transition duration-200 ease-in-out border-t-4 border-dblue-500"><header class="relative max-w-6xl mx-auto px-6 lg:px-8 text-xl mt-3"><div class="flex items-center justify-between md:h-16"><div class="w-full justify-between flex flex-col md:flex-row md:items-center"><div class="flex justify-between"><span class="flex flex-row items-center"><img src="/images/logo-large.png" alt="Javascript Adventures logo"/><span class="ml-2 hidden sm:inline-block" style="font-family:PT Mono, monospace"> <!-- -->Quests In Code</span></span><div class="absolute right-0 top-0 mt-2 mr-5 flex md:hidden"><button class="transition duration-200 ease-in-out inline-flex items-center justify-center p-2 rounded-md text-gray-900 dk:text-gray-100 hover:text-dblue-500 dk-hover:text-dblue-500 focus:outline-none focus:text-white"><svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24"><path class="inline-flex " stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path><path class="inline-flex hidden" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button></div></div><div class="hidden md:block"><div class="ml-10 flex items-baseline"><a class="navClassName" href="/posts">Posts</a><a class="navClassName" href="/topics">Topics</a><a href="/about">About</a><button class="transition duration-200 ease-in-out ml-4 px-3 py-2 text-xl font-medium text-gray-900 border-b-2 border-transparent dk:text-gray-100 dk-hover:text-dblue-400 hover:text-dblue-500 hover:text-dblue-500 focus:outline-none self-center hover:border-transparent"><svg aria-hidden="true" focusable="false" data-prefix="fad" data-icon="moon-stars" class="w-8" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><g class="fa-group"><path fill="currentColor" d="M320 32L304 0l-16 32-32 16 32 16 16 32 16-32 32-16zm138.7 149.3L432 128l-26.7 53.3L352 208l53.3 26.7L432 288l26.7-53.3L512 208z" opacity="0.4"></path><path fill="currentColor" d="M332.2 426.4c8.1-1.6 13.9 8 8.6 14.5a191.18 191.18 0 0 1-149 71.1C85.8 512 0 426 0 320c0-120 108.7-210.6 227-188.8 8.2 1.6 10.1 12.6 2.8 16.7a150.3 150.3 0 0 0-76.1 130.8c0 94 85.4 165.4 178.5 147.7z"></path></g></svg></button></div></div><div class="flex absolute z-50 inset-0 -mt-3 justify-center w-full h-screen text-center md:hidden hidden" style="background-color:hsla(215, 41%, 28%, 97%)"><button class="transition duration-200 ease-in-out absolute right-0 top-0 mt-5 mr-5 inline-flex items-center justify-center p-2 rounded-md text-gray-100 hover:text-dblue-500 focus:outline-none focus:text-white"><svg class="h-6 w-6" stroke="currentColor" fill="none" viewBox="0 0 24 24"><path class="inline-flex " stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path><path class="inline-flex hidden" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button><div class="flex flex-col justify-center"><a class="mobileNavClassName" href="/posts">Posts</a><a class="transition duration-200 ease-in-out md:ml-4 mt-2 md:mt-0 px-3 py-2 text-xl font-medium text-gray-100 border-b-2 border-transparent hover:text-dblue-500 hover:border-dblue-500 focus:outline-none" href="/topics">Topics</a><a class="transition duration-200 ease-in-out md:ml-4 mt-2 md:mt-0 px-3 py-2 text-xl font-medium text-gray-100 border-b-2 border-transparent hover:text-dblue-500 hover:border-dblue-500 focus:outline-none" href="/about">About</a><button class="transition duration-200 ease-in-out mt-2 px-3 py-2 text-xl font-medium border-b-2 border-transparent text-gray-100 hover:text-dblue-400 focus:outline-none self-center hover:border-transparent block"><svg aria-hidden="true" focusable="false" data-prefix="fad" data-icon="moon-stars" class="w-8" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><g class="fa-group"><path fill="currentColor" d="M320 32L304 0l-16 32-32 16 32 16 16 32 16-32 32-16zm138.7 149.3L432 128l-26.7 53.3L352 208l53.3 26.7L432 288l26.7-53.3L512 208z" opacity="0.4"></path><path fill="currentColor" d="M332.2 426.4c8.1-1.6 13.9 8 8.6 14.5a191.18 191.18 0 0 1-149 71.1C85.8 512 0 426 0 320c0-120 108.7-210.6 227-188.8 8.2 1.6 10.1 12.6 2.8 16.7a150.3 150.3 0 0 0-76.1 130.8c0 94 85.4 165.4 178.5 147.7z"></path></g></svg></button></div></div></div></div></header><div class="m-auto text-gray-900 dk:text-gray-300 text-lg px-6 md:max-w-3xl transition duration-200 ease-in-out"><main><div></div><div class="mt-24"><div class="text-center"><div class="flex flex-wrap justify-center"><span class="py-1 px-4 ml-4 text-sm font-semibold tracking-widest rounded-full cursor-pointer transition duration-200 ease-in-out bg-dblue-100 text-dblue-700 hover:bg-dblue-200 dk:bg-blue-900 dk:text-dblue-100 dk-hover:bg-blue-700">JavaScript</span><span class="py-1 px-4 ml-4 text-sm font-semibold tracking-widest rounded-full cursor-pointer transition duration-200 ease-in-out bg-dblue-100 text-dblue-700 hover:bg-dblue-200 dk:bg-blue-900 dk:text-dblue-100 dk-hover:bg-blue-700">React</span><span class="py-1 px-4 ml-4 text-sm font-semibold tracking-widest rounded-full cursor-pointer transition duration-200 ease-in-out bg-dblue-100 text-dblue-700 hover:bg-dblue-200 dk:bg-blue-900 dk:text-dblue-100 dk-hover:bg-blue-700">Gatsby</span></div><h1 class="my-2">Gatsby Blog From Scratch: An In-depth Guide to Starting with Gatsby</h1><div class="mb-8 text-gray-700 dk:text-gray-500 flex justify-center flex-col sm:flex-row sm:text-center"><span class="mr-2">2020-04-17<!-- --> <span class="hidden sm:inline-block">•</span> </span><span class="flex items-center justify-center"><span class="flex mr-2"><img src="/images/heart.png" alt="Pixel heart" style="height:24px;image-rendering:pixelated" class=""/><img src="/images/heart.png" alt="Pixel heart" style="height:24px;image-rendering:pixelated" class="ml-1"/><img src="/images/heart.png" alt="Pixel heart" style="height:24px;image-rendering:pixelated" class="ml-1"/></span> <!-- -->3<!-- --> minute read</span></div></div><div class="w-full"></div><div class="mt-20"><span><p>Are you the type of person that likes to poke around under the hood before getting started with something new? Me too!</p><p>If you want to get started with Gatsby quickly, Gatsby has excellent <a href="https://www.gatsbyjs.org/docs/">documentation</a>. Have a look at their quick start, pick a nice starter template, create your app with the starter template, and you&#x27;re off to the races!</p><p>However, I&#x27;ve never been one that takes complexity for granted. To be sure, there is a reason for the complexity Gatsby introduces, but you truly need to understand it in order to appreciate what it brings to the table. Complexity is a trade-off, so you really need to consider why you would want to use something like Gatsby over, say, a simple site with just HTML and some CSS and javascript sprinkled in as needed.</p><h2>Plan to Learn Gatsby In Depth</h2><p>Gatsby has a lot of moving pieces, particularly when you start adding plugins, and it&#x27;s easy to get overwhelmed as you inevitably start customizing to suite your sites and preferences. Plugins are an extremely useful tool in Gatsby, and the community that has developed around it is <a href="https://www.gatsbyjs.org/plugins/">quite rich</a>.</p><p>However, the best way to understand Gatsby is starting completely bare, with no plugins or starters, even those developed by the Gatsby team. Eventually, those tools will add much convenience and velocity to your development. But if you want to understand everything that&#x27;s going on, its nice to start from scratch and work your way up.</p><p>Clearly there are far too many plugins to break each one down and understand them all in one shot before you even start using Gatsby, and that would be counter to the purpose of Gatsby. But there are a few core features of Gatsby which, if you can dig into them deeply and understand them at the lowest level, you will have a solid foundation upon which to draw from in your work with Gatsby.</p><p>After our exploration of Gatsby today, we&#x27;ll:</p><ul><li>Understand how Gatsby&#x27;s build process works</li><li>Understand how most plugins work and how they hook into Gatsby</li><li>Have a clear vision for building our own plugins or extensions when we need them</li></ul><p>The three core features that most websites will be utilizing in Gatsby that we&#x27;ll look to dig into are:</p><ul><li>Sourcing external data for consumption in Gatsby</li><li>Passing data to components to programmatically create pages</li><li>Plugging into Gatsby&#x27;s data management layer, GraphQL</li></ul><p>Once we manually implement a basic functioning version of all of these, we&#x27;ll have an appreciation for the simplicity that Gatsby&#x27;s plugin architecture brings and we&#x27;ll swap out our code for the plugins that do the same thing and take advantage of the many performance improvements Gatsby offers.</p><h2>What are we building?</h2><p>For today&#x27;s adventure, we&#x27;ll be building…this very blog! A blog is among the most common use cases for a static site generator, so it&#x27;s a great place to start learning about Gatsby. I chose Gatsby for this site (after some substantially extensive, yet characteristic, angst about whether to use a CMS like <a href="https://wordpress.org/">WordPress</a> or any of a large number of <a href="https://www.staticgen.com/">other static site generators</a>…) because I wanted to keep server costs to a minimum, as well as leverage my existing knowledge of javascript and React to add many bits of dynamism to the site that would typically be more challenging with a CMS or a static site generator that uses a different programming language.</p><p>Gatsby&#x27;s documentation has a great summary of <a href="https://www.gatsbyjs.org/features/cms/">why you would use it over a traditional CMS</a>, or <a href="https://www.gatsbyjs.org/features/jamstack/">other static site generators</a>.</p><p>In the end, they all achieve very similar things in different ways, so the choice is personal. However, after some tinkering with various options, I&#x27;ve found Gatsby to be the best for the most important reason: it&#x27;s the most fun to use!</p><p>I&#x27;ve played a bit with Gatsby in my experimentation, but I don&#x27;t feel that I&#x27;ve learned it enough to be satisfied with my foundational knowledge. So, this post will be an exploration of learning Gatsby in depth by building a thing from scratch!</p><p>The final version using our custom code is available at the <a href="https://github.com/Daynil/quests-in-code/tree/final-plugin-free">final-plugin-free</a> branch in the Github repository for this blog, if you ever want to see the full picture of the code.</p><h2>Starting From Scratch</h2><p>To get started, let&#x27;s use the gatsby CLI to generate the default blank starter.</p><pre><code class="hljs language-bash">$ npm install -g gatsby-cli
$ gatsby new quests-in-code
</code></pre><p>The Gatsby CLI allows you to pass an optional parameter called <code>starter-url</code>, which can provide many useful defaults such as plugins for parsing markdown, for using typescript, etc. However, for our learning purposes we want to start with the minimum available option. If you do not pass anything for the starter-url, the default blank starter used, <code>gatsby-starter-default</code>. You can also pass <code>gatsby-starter-default</code> as the parameter, but that does the same thing as omitting it. Once Gatsby finishes installing everything, you&#x27;ll see a success message. Let&#x27;s explore what Gatsby has scaffolded out for us.</p><pre><code class="hljs language-bash">$ <span class="hljs-built_in">cd</span> quests-in-code
$ code .
$ gatsby develop
</code></pre><p>What we see is a very simple starter application with a few things already in place. We have 3 pages, a few components to be used within pages, and a couple of images.</p><p>If you open up <code>gatsby-config.js</code>, you&#x27;ll notice there are actually already a number of plugins included even in this default blank starter:</p><div class="remark-code-title">gatsby-config.js</div><pre><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">siteMetadata</span>: {
    <span class="hljs-attr">title</span>: <span class="hljs-string">`Gatsby Default Starter`</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">`Kick off your next, great Gatsby project with this default starter. This barebones starter ships with the main Gatsby configuration files you might need.`</span>,
    <span class="hljs-attr">author</span>: <span class="hljs-string">`@gatsbyjs`</span>
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-string">`gatsby-plugin-react-helmet`</span>,
    {
      <span class="hljs-attr">resolve</span>: <span class="hljs-string">`gatsby-source-filesystem`</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">`images`</span>,
        <span class="hljs-attr">path</span>: <span class="hljs-string">`<span class="hljs-subst">${__dirname}</span>/src/images`</span>
      }
    },
    <span class="hljs-string">`gatsby-transformer-sharp`</span>,
    <span class="hljs-string">`gatsby-plugin-sharp`</span>,
    {
      <span class="hljs-attr">resolve</span>: <span class="hljs-string">`gatsby-plugin-manifest`</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">`gatsby-starter-default`</span>,
        <span class="hljs-attr">short_name</span>: <span class="hljs-string">`starter`</span>,
        <span class="hljs-attr">start_url</span>: <span class="hljs-string">`/`</span>,
        <span class="hljs-attr">background_color</span>: <span class="hljs-string">`#663399`</span>,
        <span class="hljs-attr">theme_color</span>: <span class="hljs-string">`#663399`</span>,
        <span class="hljs-attr">display</span>: <span class="hljs-string">`minimal-ui`</span>,
        <span class="hljs-attr">icon</span>: <span class="hljs-string">`src/images/gatsby-icon.png`</span> <span class="hljs-comment">// This path is relative to the root of the site.</span>
      }
    }
    <span class="hljs-comment">// this (optional) plugin enables Progressive Web App + Offline functionality</span>
    <span class="hljs-comment">// To learn more, visit: https://gatsby.dev/offline</span>
    <span class="hljs-comment">// `gatsby-plugin-offline`,</span>
  ]
};
</code></pre><p>We will be needing all of these eventually, but we will start building out our blog without them so we can understand what they are for.</p><p>First, let&#x27;s create a simple page ourselves just to make sure we understand the very basics. Create a file called <code>blog-post.js</code> in the pages folder. Gatsby automatically builds a page with the URL as the file name for files in this folder. Throw an image called <code>cat-1.jpg</code> into the images folder so we can explore how to use our own images.</p><div class="remark-code-title">src/pages/blog-post.js</div><pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> Cat1 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../images/cat-1.jpg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BlogPost</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Level One<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> &#x27;#<span class="hljs-attr">718096</span>&#x27;, <span class="hljs-attr">fontSize:</span> &#x27;<span class="hljs-attr">18px</span>&#x27; }}&gt;</span>March 8th, 2020<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        This is the first post in the blog, currently just a placeholder but we
        will soon add lots of <span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>awesome<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span> meaningful content.
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{Cat1}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;700px&quot;</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
</code></pre><p>Now, navigate to http://localhost:8000/blog-post and you will see our first blog post show up as expected.</p><p><img src="./level-one-post.png" alt="Blogpost built in React screenshot"/></p><p>Awesome, that was easy enough right?!</p><p>Of course, as simple as Gatsby makes this, we don&#x27;t want to have to take the time to write all of our blog posts in raw JSX. There are several ways to author content in a more user friendly way, then use Gatsby to create pages out of it. One of the most popular ways is using a content management system, such as <a href="https://www.netlifycms.org/">Netlify CMS</a>. Another popular and simple way, which we will use, is markdown files.</p><h2>Using Markdown</h2><p>Let&#x27;s create a couple of super simple markdown placeholders for our first 2 posts. We&#x27;ll create a folder called content in the base directory with two markdown files, them move our cat image here as well. Here&#x27;s what we will have as of now:</p><p><img src="./markdown-folder.png" alt="Gatsby content folder structure screenshot"/></p><div class="remark-code-title">content/level-one.md</div><pre><code class="hljs language-markdown"><span class="hljs-section"># Level One</span>

This is the first post in the blog, currently just a placeholder but we will soon add lots of <span class="hljs-emphasis">_awesome_</span> meaningful content.

<span class="hljs-section">### This came from a markdown file!</span>

![<span class="hljs-string">Funny Cat</span>](<span class="hljs-link">/cat-1.jpg</span>)
</code></pre><div class="remark-code-title">content/level-two.md</div><pre><code class="hljs language-markdown"><span class="hljs-section"># Level Two</span>

This is our second post, we&#x27;re <span class="hljs-emphasis">_really_</span> on a roll now aren&#x27;t we?
</code></pre><p>Great, we&#x27;ve got some posts written! But now what, how do we see them in the browser?</p><p>This is where our adventure really begins to get interesting!</p><p>Right now, Gatsby doesn&#x27;t know anything about our markdown files. We need to tell Gatsby how to process and display these markdown files. Our current <code>blog-post.js</code> page file just displays some hard-coded strings and we&#x27;re not creating any pages for the markdown files.</p><p>Let&#x27;s start fix this by teaching Gatsby how to parse a markdown file into HTML so that we can use it in our site. First, let&#x27;s install a markdown parser. There are several options, but we&#x27;ll use <a href="https://remark.js.org/">remark</a> since that&#x27;s what Gatsby&#x27;s main markdown plugin uses, which we will switch to once we understand what it is doing under the hood.</p><pre><code class="hljs language-bash">$ npm install remark remark-html
</code></pre><p>Gatsby has a special file called <code>gatsby-node.js</code> which is run once when your site is being built. We can use this file to parse the markdown files. Let&#x27;s start by just parsing our first markdown post and logging it out to the console.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> remark = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;remark&#x27;</span>);
<span class="hljs-keyword">const</span> html = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;remark-html&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-built_in">exports</span>.createPages = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> post1 = fs.readFileSync(<span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./content/level-one.md&#x27;</span>));

  remark()
    .use(html)
    .process(post1, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, file</span>) </span>{
      <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(file));
    });
};

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// &lt;h1&gt;Level One&lt;/h1&gt;</span>
<span class="hljs-comment">// &lt;p&gt;This is the first post in the blog, currently just a placeholder but we will soon add lots of &lt;em&gt;awesome&lt;/em&gt; meaningful content.&lt;/p&gt;</span>
<span class="hljs-comment">// &lt;p&gt;&lt;img src=&quot;/cat-1.jpg&quot; alt=&quot;Funny Cat&quot;&gt;&lt;/p&gt;</span>
</code></pre><p>Great! So now we&#x27;ve read in our markdown file into memory with node&#x27;s readFileSync API, then parsed it to HTML using remark. Now we need a way to display this parsed HTML with Gatsby.</p><h2>Programmatic Page Generation</h2><p>In Gatsby, you create page templates in order to programmatically generate pages. So, let&#x27;s move our <code>blog-post.js</code> component to <code>src/templates</code> (and remove the hard coded image if you moved it to the content folder earlier). Now that <code>blog-post.js</code> is in templates and not pages, Gatsby will no longer automatically generate a page for it. Gatsby expects us to explain how to create this page programmatically, so let&#x27;s do that.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> remark = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;remark&#x27;</span>);
<span class="hljs-keyword">const</span> html = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;remark-html&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-built_in">exports</span>.createPages = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> post1 = fs.readFileSync(<span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./content/level-one.md&#x27;</span>));

  remark()
    .use(html)
    .process(post1, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, file</span>) </span>{
      <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(file));
      createPage({
        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/blog-post&#x27;</span>,
        <span class="hljs-attr">component</span>: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./src/templates/blog-post.js&#x27;</span>)
      });
    });
};
</code></pre><p>Now restart the development server and go back to http://localhost:8000/blog-post and you&#x27;ll see that it still works. Ok, what was the point of that? We&#x27;ve just imperatively done what Gatsby did for us automatically by convention when this file was in the pages. Well, this is where the power of Gatsby comes in. Now that we can tap into Gatsby&#x27;s build system, we can use whatever data we want and map it to page templates. We can make use of our parsed markdown file by passing it to our template using createPage&#x27;s context property.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-comment">// …</span>
remark()
  .use(html)
  .process(post1, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, file</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(file));
    createPage({
      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/blog-post&#x27;</span>,
      <span class="hljs-attr">component</span>: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./src/templates/blog-post.js&#x27;</span>),
      <span class="hljs-attr">context</span>: {
        <span class="hljs-attr">post</span>: <span class="hljs-built_in">String</span>(file)
      }
    });
  });
</code></pre><p>Now our blog-post template component has access to the context via the pageContext prop, so let&#x27;s replace the hard-coded post in blog-post.js with dynamically set HTML from the markdown.</p><div class="remark-code-title">src/templates/blog-post.js</div><pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BlogPost</span>(<span class="hljs-params">{ pageContext }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">pageContext.post</span> }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}
</code></pre><p>Restart your development server and go back to our blog post URL. It works! However, there is one small issue - the image doesn&#x27;t load, what gives?! The path is set correctly, but Gatsby doesn&#x27;t know where to look for the image, since we have only told Gatsby how to process markdown files, not images.</p><p>When you pass a relative path, by default Gatsby looks for images at the root static folder: <code>static/</code>. If we move our <code>cat-1.jpg</code> from <code>content/cat-1.jpg</code> to <code>static/cat-1.jpg</code> and refresh the development server, the image will show up as expected. This isn&#x27;t ideal, since we&#x27;re creating a conceptual gap between where a file&#x27;s relative path is in your development environment&#x27;s folder structure versus where it ends up in Gatsby&#x27;s runtime environment.</p><p>Gatsby&#x27;s plugins solve this by registering the relative paths and mapping them to the static folder in the output directory. For example, you&#x27;ll see with one of the default images from the starter, in the source directory, it lives under <code>src/images/gatsby-astronaut.png</code>, but upon running <code>$ gatsby build</code>, the image gets moved to <code>public/static/{generatedId}/{generatedId}/gatsby-astronaut.png</code>. Gatsby&#x27;s plugin also generates different image sizes for each image, which is what the various subfolders for each image contain.</p><p><img src="./astronaut-src.png" alt="Gatsby source image folder structure"/></p><p><img src="./astronaut-build.png" alt="Gatsby public static build folder structure"/></p><p>We&#x27;ll also note that once we put our <code>cat-1.jpg</code> into the static folder, during the build Gatsby puts it in the root directory, not the static directory, so we can access it directly using what appears to be a relative path: <code>/cat-1.jpg</code>.</p><p><img src="./cat-build.png" alt="Gatsby source static build folder structure"/></p><p>Essentially, we haven&#x27;t told Gatsby anything about how to process images, but its build process just moves files in the static directory as-is to the root public directory. We can allow the use of more logical relative paths imperatively by hooking into Gatsby&#x27;s build system and moving the files into the static folder at build time or moving it to the appropriate folder in the built directory. However, let&#x27;s just leave it in the static folder for now so we can focus on the markdown files first.</p><p>Our blog-post template is now fully dynamic and is the only thing we need to render all of our markdown files. Let&#x27;s prove this out by creating another page for our other post. The only thing we need to change is the path, creating a unique slug for each post.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-comment">// …</span>
<span class="hljs-built_in">exports</span>.createPages = <span class="hljs-keyword">async</span> ({ actions }) =&gt; {
  <span class="hljs-keyword">const</span> { createPage } = actions;

  <span class="hljs-keyword">const</span> contentDir = fs.readdirSync(<span class="hljs-string">&#x27;./content/&#x27;</span>);

  contentDir.forEach(<span class="hljs-function"><span class="hljs-params">mdFilePath</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> post = fs.readFileSync(<span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">`./content/<span class="hljs-subst">${mdFilePath}</span>`</span>));

    remark()
      .use(html)
      .process(post, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, file</span>) </span>{
        <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(file));
        createPage({
          <span class="hljs-attr">path</span>: <span class="hljs-string">`/<span class="hljs-subst">${mdFilePath.replace(<span class="hljs-regexp">/\.[^/.]+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)}</span>`</span>,
          <span class="hljs-attr">component</span>: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./src/templates/blog-post.js&#x27;</span>),
          <span class="hljs-attr">context</span>: {
            <span class="hljs-attr">post</span>: <span class="hljs-built_in">String</span>(file)
          }
        });
      });
  });
};
</code></pre><p>Now refresh the development server, and both of our posts will be available at the URLs corresponding to their markdown file name: http://localhost:8000/level-one and http://localhost:8000/level-two. Neat!</p><h2>Code Block Syntax Highlighting</h2><p>Now, given that we&#x27;re coders, we&#x27;re obviously going to want to be able to utilize syntax highlighted code in our blog to show off our cool code snippets right? Of course, silly question. So let&#x27;s add a markdown file with some code and see how it looks with our current setup.</p><div class="remark-code-title">content/level-three.md</div><pre><code class="hljs language-markdown"><span class="hljs-section"># Level Three</span>

This is a really informative post with a really fancy code snippet.

<span class="hljs-code">```javascript
const pluckDeep = key =&gt; obj =&gt;
  key.split(&#x27;.&#x27;).reduce((accum, key) =&gt; accum[key], obj);

const compose = (...fns) =&gt; res =&gt;
  fns.reduce((accum, next) =&gt; next(accum), res);

const unfold = (f, seed) =&gt; {
  const go = (f, seed, acc) =&gt; {
    const res = f(seed);
    return res ? go(f, res[1], acc.concat([res[0]])) : acc;
  };
  return go(f, seed, []);
};
```</span>
</code></pre><p>Navigate to our new /level-three page URL in the browser and you&#x27;ll see that we have a nice code block with our code, but no syntax highlighting. That may work fine for Medium (😏) but we&#x27;re much cooler than that, so let&#x27;s add it! First, we need to install a syntax highlighter. However, we also need to install a few additional packages as well to help us with this new parsing task. Syntax highlighting code in markdown is more complex than just turning it straight into HTML since we now have to tokenize individual characters and highlight them appropriately depending on the language. To achieve this, we can use <a href="https://prismjs.com/">PrismJS</a> and a few helpers.</p><pre><code class="hljs language-bash">$ npm install prismjs unified remark-parse remark-rehype rehype-prism rehype-stringify
</code></pre><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> unified = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;unified&#x27;</span>);
<span class="hljs-keyword">const</span> remarkParse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;remark-parse&#x27;</span>);
<span class="hljs-keyword">const</span> remarkRehype = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;remark-rehype&#x27;</span>);
<span class="hljs-keyword">const</span> rehypePrism = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;rehype-prism&#x27;</span>);
<span class="hljs-keyword">const</span> rehypeStringify = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;rehype-stringify&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);

<span class="hljs-built_in">exports</span>.createPages = <span class="hljs-keyword">async</span> ({ actions }) =&gt; {
  <span class="hljs-keyword">const</span> { createPage } = actions;

  <span class="hljs-keyword">const</span> contentDir = fs.readdirSync(<span class="hljs-string">&#x27;./content/&#x27;</span>);

  contentDir.forEach(<span class="hljs-function"><span class="hljs-params">mdFilePath</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> post = fs.readFileSync(<span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">`./content/<span class="hljs-subst">${mdFilePath}</span>`</span>));

    unified()
      .use(remarkParse)
      .use(remarkRehype)
      .use(rehypePrism)
      .use(rehypeStringify)
      .process(post, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, file</span>) </span>{
        <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);
        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(file));
        createPage({
          <span class="hljs-attr">path</span>: <span class="hljs-string">`/<span class="hljs-subst">${mdFilePath.replace(<span class="hljs-regexp">/\.[^/.]+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)}</span>`</span>,
          <span class="hljs-attr">component</span>: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./src/templates/blog-post.js&#x27;</span>),
          <span class="hljs-attr">context</span>: {
            <span class="hljs-attr">post</span>: <span class="hljs-built_in">String</span>(file)
          }
        });
      });
  });
};
</code></pre><p>Here we&#x27;re parsing our markdown into tokens, using prism to apply the appropriate classes to each token, then turning it into HTML. However, if you refresh now, you&#x27;ll see the syntax is still not highlighted. We&#x27;ve inserted span elements with the correct classes to highlight each token of code, but we don&#x27;t have any CSS classes set up yet. Let&#x27;s take one of Prism&#x27;s default themes, tomorrow night, and use that. You can insert styles globally in <code>gatsby-browser.js</code>.</p><div class="remark-code-title">gatsby-browser.js</div><pre><code class="hljs language-javascript"><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;prismjs/themes/prism-tomorrow.css&#x27;</span>);
</code></pre><p>Restart Gatsby and you&#x27;ll see the syntax is now highlighted!</p><h2>Bringing it together with GraphQL</h2><p>We&#x27;ve now got the skeleton of a fully functioning technical blog. However, as we&#x27;ve seen with our problem with relative image paths, handling the data can get a bit hairy. Gatsby helps simplify and streamline this process by allowing each data source to register its contents in its GraphQL layer. Once registered, you can issue concise GraphQL queries to get just the data you need for each page, using the same syntax regardless of the source of the data.</p><p>Let&#x27;s start by loading our markdown file information into GraphQL.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-comment">//…</span>
<span class="hljs-keyword">const</span> { slash } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gatsby-core-utils&#x27;</span>);

<span class="hljs-built_in">exports</span>.sourceNodes = <span class="hljs-function">(<span class="hljs-params">{ actions, createNodeId, createContentDigest }</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { createNode } = actions;

  <span class="hljs-keyword">const</span> contentDir = fs.readdirSync(<span class="hljs-string">&#x27;./content/&#x27;</span>);

  contentDir.forEach(<span class="hljs-function"><span class="hljs-params">mdFilePath</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> nodeData = {
      <span class="hljs-attr">absolutePath</span>: slash(<span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">`./content/<span class="hljs-subst">${mdFilePath}</span>`</span>)),
      <span class="hljs-attr">relativePath</span>: mdFilePath
    };

    <span class="hljs-keyword">const</span> nodeMetaData = {
      <span class="hljs-attr">id</span>: createNodeId(<span class="hljs-string">`id-<span class="hljs-subst">${mdFilePath}</span>`</span>),
      <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">children</span>: [],
      <span class="hljs-attr">internal</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BlogMDFile&#x27;</span>,
        <span class="hljs-attr">mediaType</span>: <span class="hljs-string">&#x27;text/markdown&#x27;</span>,
        <span class="hljs-attr">contentDigest</span>: createContentDigest(nodeData)
      }
    };

    createNode(<span class="hljs-built_in">Object</span>.assign({}, nodeData, nodeMetaData));
  });

  <span class="hljs-keyword">return</span>;
};
</code></pre><p>Instead of just looping through each file, reading it, and parsing it all in one step, we&#x27;re breaking it up into two pieces. Gatsby has the concept of &quot;source&quot; plugins, which load in data from a given source, and a &quot;transformer&quot; plugin, which converts data from one format to another. This level of modularity allows you to grab data from novel &quot;sources&quot; while still leveraging existing transformer plugs.</p><p>Let&#x27;s say you have your markdown files hosted on some remote server for which there isn&#x27;t a plugin yet. You can create a source, like we did above, to load the content in. Because you specified it was of type <code>text/markdown</code> in the <code>internal.mediaType</code> metadata, any available markdown transformer plugin can subsequently parse your data for this source, without knowing anything about how to get data from your novel source!</p><p>So we&#x27;ve just built the &quot;source&quot; portion. In the case of local filesystem sources, we don&#x27;t actually need to load the raw data in unless we&#x27;ll be using it. Our raw data is markdown, which we&#x27;ll need to parse to HTML before we use it, so our source is just a pointer to the file in the form of its absolute path. If you were actually creating a plugin, Gatsby provides two options to handle loading in data from source.</p><p>The simplest option, which most sources will use, is to just load your data into the node object itself. So if you had a nice bit of structured of JSON from your source, you would just add it to the <code>nodeData</code> object, similar to what we did above. If you had content that is very large and could be lazy loaded, you could define a <code>loadNodeContent</code> function for the node, which consumers can use to load the data in only when it&#x27;s requested.</p><p>This is exactly what gatsby-source-filesystem does. In the <code>nodeData</code> object, it just points to the file path as we have, and provides additional metadata, such as extension, size, etc. Then, it defines a the <code>loadNodeContent</code> function to specify how to read the data for consumers, which for a file on the local system could just be <code>fs.readFile(node.absolutePath)</code>. We&#x27;ll do something very similar.</p><p>Gatsby&#x27;s development server exposes an extremely useful interactive in-browser GraphQL IDE (integrated development environment) called GraphiQL, which shows you all of the data loaded into it. Let&#x27;s open it and find our newly created nodes. By convention, they are under the name of the <code>internal.type</code> that you assigned to the node when you made it, in our case &quot;BlogMDFile&quot;. We actually have two versions here, &quot;allBlogMdFile&quot; and &quot;blogMdFile&quot;. They expose the same information, but as expected, the all version just shows all the nodes of the type while the other allows you to filter for individual ones.</p><p><img src="./graphiql.png" alt="Gatsby GraphiQL in-browser query exploration tool"/></p><p>Great! Now that we&#x27;ve got our markdown files &quot;sourced&quot; into the GraphQL layer, we&#x27;re going to use the information from these newly created nodes and create the &quot;transformer&quot; portion of our plugin, which will take the files and parse them, then load them into GraphQL as well.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-comment">//…</span>
<span class="hljs-built_in">exports</span>.onCreateNode = <span class="hljs-keyword">async</span> ({
  node,
  actions,
  createNodeId,
  createContentDigest
}) =&gt; {
  <span class="hljs-keyword">const</span> { createNode, createParentChildLink } = actions;
  <span class="hljs-keyword">if</span> (node.internal.mediaType !== <span class="hljs-string">&#x27;text/markdown&#x27;</span>) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.readFileSync(node.absolutePath);
  unified()
    .use(remarkParse)
    .use(remarkRehype)
    .use(rehypePrism)
    .use(rehypeStringify)
    .process(content, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, file</span>) </span>{
      <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>(file));

      <span class="hljs-keyword">const</span> htmlNodeData = {
        <span class="hljs-attr">html</span>: <span class="hljs-built_in">String</span>(file),
        <span class="hljs-attr">slug</span>: <span class="hljs-string">`/<span class="hljs-subst">${node.relativePath.replace(<span class="hljs-regexp">/\.[^/.]+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)}</span>`</span>
      };

      <span class="hljs-keyword">const</span> htmlNodeMetaData = {
        <span class="hljs-attr">id</span>: createNodeId(<span class="hljs-string">`id-html-<span class="hljs-subst">${node.absolutePath}</span>`</span>),
        <span class="hljs-attr">parent</span>: node.id,
        <span class="hljs-attr">children</span>: [],
        <span class="hljs-attr">internal</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BlogHTML&#x27;</span>,
          <span class="hljs-attr">mediaType</span>: <span class="hljs-string">&#x27;text/html&#x27;</span>,
          <span class="hljs-attr">contentDigest</span>: createContentDigest(<span class="hljs-built_in">String</span>(file))
        }
      };

      <span class="hljs-keyword">const</span> htmlNode = <span class="hljs-built_in">Object</span>.assign({}, htmlNodeData, htmlNodeMetaData);

      createNode(htmlNode);
      createParentChildLink({ <span class="hljs-attr">parent</span>: node, <span class="hljs-attr">child</span>: htmlNode });
    });
};
</code></pre><p>Here we&#x27;re just hooking into Gatsby&#x27;s build process, looking for when nodes of type <code>text/markdown</code> are created, then using our existing code to parse that node&#x27;s data to HTML and create a new node with it. There&#x27;s no real difference here versus what we did back when we first created the code that parses our markdown, we&#x27;ve just split it up and loaded it into GraphQL.</p><p>Great, so now we&#x27;ve got our parsed HTML again, but now it&#x27;s loaded into the GraphQL layer. Now we can query that data the same way we would query anything in Gatsby. Let&#x27;s rewrite our <code>createPages</code> function to leverage GraphQL.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-comment">//…</span>
<span class="hljs-built_in">exports</span>.createPages = <span class="hljs-keyword">async</span> ({ graphql, actions }) =&gt; {
  <span class="hljs-keyword">const</span> { createPage } = actions;

  <span class="hljs-keyword">const</span> markdownPages = <span class="hljs-keyword">await</span> graphql(<span class="hljs-string">`
    query {
      allBlogHtml {
        edges {
          node {
            slug
          }
        }
      }
    }
  `</span>);

  markdownPages.data.allBlogHtml.edges.forEach(<span class="hljs-function">(<span class="hljs-params">{ node }</span>) =&gt;</span> {
    createPage({
      <span class="hljs-attr">path</span>: node.slug,
      <span class="hljs-attr">component</span>: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./src/templates/blog-post.js&#x27;</span>),
      <span class="hljs-attr">context</span>: {
        <span class="hljs-attr">slug</span>: node.slug
      }
    });
  });
};
</code></pre><p>Awesome, that dramatically simplifies our <code>createPages</code> function. Now we&#x27;re just querying grabbing the slug for each post and create a page for it. However, you&#x27;ll note we&#x27;re no longer passing the parsed HTML in the context. Well, how will our template know what to render?! Well, that&#x27;s the beauty of GraphQL. We can now colocate the query for the data the template needs with the template itself! The only thing we need when we&#x27;re actually creating the pages is the slug.</p><div class="remark-code-title">src/templates/blog-past.js</div><pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { graphql } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;gatsby&#x27;</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BlogPost</span>(<span class="hljs-params">{ data }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">data.blogHtml.html</span> }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> query = graphql<span class="hljs-string">`
  query($slug: String!) {
    blogHtml(slug: { eq: $slug }) {
      html
    }
  }
`</span>;
</code></pre><p>We&#x27;ve passed the slug in as context, and when a page is created for a template, you can use keys from the context object to match up with arguments in the GraphQL page query. Variables in GraphQL are prefaced with <code>$</code>, so here passing a <code>slug</code> property into the context will pass <code>$slug</code> into the query, and we&#x27;ve just specified it is of type string. The results of the query are now available in the props of the component under the aptly named <code>data</code> property by convention. <code>pageContext</code> is also still available as a separate object in the component&#x27;s props if it is needed (e.g. <code>BlogPost({ data, context })</code>), but in our case, the slug was only needed for the query.</p><p>Restart Gatsby and you&#x27;ll see that our pages are once again available as they were, success!!</p><h2>Dealing with Images</h2><p>One last thing that we need to do is actually move our sourced files from our source directory to somewhere we can access them in the public build directory. This isn&#x27;t strictly necessary for the markdown files, since we&#x27;ve already parsed all the information out of them into a string on the <code>blogHtml.html</code> graphql node. However, remember our problem with the images? Here&#x27;s where we fix that problem!</p><p>Recall that we temporarily dealt with the issue of our cat image not being available in the public directory by just moving it to Gatsby&#x27;s <code>src/static</code> folder. From there, Gatsby just dumps all the files into the root <code>public</code> folder at build time, where we can use them in the runtime environment. The issue we had was the logical disconnect between where files are in the development <code>src</code> directory versus where they end up in the <code>public</code> directory at runtime.</p><p>Let&#x27;s deal with this in a way that lets us organize our files logically. We&#x27;ll move the <code>cat-1.jpg</code> back to the content folder, alongside our markdown posts, as we originally had it. Also, we&#x27;ll go into our <code>level-one.md</code> and make a slight adjustment to the image url to make it relative again, changing <code>![Funny Cat](/cat-1.jpg)</code> to <code>![Funny Cat](./cat-1.jpg)</code>.</p><p>Next, we need to do a few new things in our <code>sourceNodes</code> function. First, create a <code>publicURL</code> field in node data which will tell us where each file we process will sit in the public directory. We&#x27;ll put all of our files into the <code>public/static</code> directory. Now that we&#x27;re processing images in addition to markdown files, we&#x27;ll need to set our <code>internal.mediaType</code> to correctly reflect the file type, otherwise our transformer will have a cow trying to parse an jpeg file into HTML. Then, we&#x27;ll copy each file to its public location, so it will be accessible to our blog posts at runtime.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);

<span class="hljs-built_in">exports</span>.sourceNodes = <span class="hljs-function">(<span class="hljs-params">{ actions, createNodeId, createContentDigest }</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> { createNode } = actions;

  <span class="hljs-keyword">const</span> contentDir = fs.readdirSync(<span class="hljs-string">&#x27;./content/&#x27;</span>);

  contentDir.forEach(<span class="hljs-function"><span class="hljs-params">mdFilePath</span> =&gt;</span> {
    <span class="hljs-keyword">const</span> nodeData = {
      <span class="hljs-attr">absolutePath</span>: slash(<span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">`./content/<span class="hljs-subst">${mdFilePath}</span>`</span>)),
      <span class="hljs-attr">relativePath</span>: mdFilePath,
      <span class="hljs-attr">publicURL</span>: slash(
        path.resolve(process.cwd(), <span class="hljs-string">&#x27;public&#x27;</span>, <span class="hljs-string">&#x27;static&#x27;</span>, mdFilePath)
      ),
      <span class="hljs-attr">publicRelativePath</span>: <span class="hljs-string">`/static/<span class="hljs-subst">${mdFilePath}</span>`</span>
    };

    <span class="hljs-keyword">const</span> extension = mdFilePath.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>];

    <span class="hljs-keyword">const</span> nodeMetaData = {
      <span class="hljs-attr">id</span>: createNodeId(<span class="hljs-string">`id-<span class="hljs-subst">${mdFilePath}</span>`</span>),
      <span class="hljs-attr">parent</span>: <span class="hljs-literal">null</span>,
      <span class="hljs-attr">children</span>: [],
      <span class="hljs-attr">internal</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BlogMDFile&#x27;</span>,
        <span class="hljs-attr">mediaType</span>: extension === <span class="hljs-string">&#x27;md&#x27;</span> ? <span class="hljs-string">&#x27;text/markdown&#x27;</span> : <span class="hljs-string">&#x27;image/jpeg&#x27;</span>,
        <span class="hljs-attr">contentDigest</span>: createContentDigest(nodeData)
      }
    };

    fs.copyFileSync(nodeData.absolutePath, nodeData.publicURL);

    createNode(<span class="hljs-built_in">Object</span>.assign({}, nodeData, nodeMetaData));
  });

  <span class="hljs-keyword">return</span>;
};
</code></pre><p>Now, we can access our images in runtime. If we wanted to use our cat image directly in our JSX, we could write a static or page query to grab the url. For example, we can create the following query in our blog post template to pull in the public URL:</p><div class="remark-code-title">src/templates/blog-post.js</div><pre><code class="hljs language-jsx"><span class="hljs-comment">//…</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BlogPost</span>(<span class="hljs-params">{ data }</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{data.blogMdFile.publicRelativePath}</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">data.blogHtml.html</span> }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>;
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> query = graphql<span class="hljs-string">`
  query($slug: String!) {
    blogHtml(slug: { eq: $slug }) {
      html
    }
    blogMdFile(relativePath: { eq: &quot;cat-1.jpg&quot; }) {
      publicRelativePath
    }
  }
`</span>;
</code></pre><p>In our case, the relative path is the same as the file name since the image is sitting in the same folder as the rest of our content, so we can just search by the file name. We grab the public relative path we created in our node for our files, and since we moved the image during the build to the static directory, we can now reference the files.</p><p>However, the astute reader will note that we&#x27;ve clearly not solved the problem we set out to yet. In our markdown file, we referenced the image as relative to the source environment markdown file&#x27;s location <code>./cat-1.jpg</code>. But we moved the files to a static folder, so it still won&#x27;t resolve properly in the runtime environment. Since our file is written in markdown, we can&#x27;t do any fancy graphql querying to retrieve files, nor would we want to. We just want to type a relative string with the file name in our blog post markdown and have it resolve properly. What do??</p><p>This piece is just a bit trickier, but still worth exploring to make sure we&#x27;ve fully wrapped our heads around everything going on under the hood. The complexity is that the markdown file to which the image is relative no longer exists as far as the runtime environment is concerned - it&#x27;s parsed into an HTML fragment, which we insert into our template. So our only remaining choice is to fake it, hot-swapping the original relative URL with the public directory we know the file is in.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-comment">//…</span>
<span class="hljs-keyword">const</span> visit = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;unist-util-visit&#x27;</span>);

<span class="hljs-comment">//…</span>
<span class="hljs-built_in">exports</span>.onCreateNode = <span class="hljs-keyword">async</span> ({
  node,
  actions,
  createNodeId,
  createContentDigest
}) =&gt; {
  <span class="hljs-keyword">const</span> { createNode, createParentChildLink } = actions;
  <span class="hljs-keyword">if</span> (node.internal.mediaType !== <span class="hljs-string">&#x27;text/markdown&#x27;</span>) <span class="hljs-keyword">return</span>;

  <span class="hljs-keyword">const</span> content = <span class="hljs-keyword">await</span> fs.readFileSync(node.absolutePath);
  unified()
    .use(remarkParse)
    .use(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">transformer</span>(<span class="hljs-params">tree, file</span>) </span>{
        visit(tree, <span class="hljs-string">&#x27;image&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>{
          <span class="hljs-keyword">const</span> imageName = node.url.split(<span class="hljs-string">&#x27;./&#x27;</span>)[<span class="hljs-number">1</span>];
          node.url = <span class="hljs-string">`/static/<span class="hljs-subst">${imageName}</span>`</span>;
        });
      };
    })
    .use(remarkRehype)
    .use(rehypePrism)
    .use(rehypeStringify)
    .process(content, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, file</span>) </span>{
      <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err);

      <span class="hljs-keyword">const</span> htmlNodeData = {
        <span class="hljs-attr">html</span>: <span class="hljs-built_in">String</span>(file),
        <span class="hljs-attr">slug</span>: <span class="hljs-string">`/<span class="hljs-subst">${node.relativePath.replace(<span class="hljs-regexp">/\.[^/.]+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>)}</span>`</span>
      };

      <span class="hljs-keyword">const</span> htmlNodeMetaData = {
        <span class="hljs-attr">id</span>: createNodeId(<span class="hljs-string">`id-html-<span class="hljs-subst">${node.absolutePath}</span>`</span>),
        <span class="hljs-attr">parent</span>: node.id,
        <span class="hljs-attr">children</span>: [],
        <span class="hljs-attr">internal</span>: {
          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;BlogHTML&#x27;</span>,
          <span class="hljs-attr">mediaType</span>: <span class="hljs-string">&#x27;text/html&#x27;</span>,
          <span class="hljs-attr">contentDigest</span>: createContentDigest(<span class="hljs-built_in">String</span>(file))
        }
      };

      <span class="hljs-keyword">const</span> htmlNode = <span class="hljs-built_in">Object</span>.assign({}, htmlNodeData, htmlNodeMetaData);

      createNode(htmlNode);
      createParentChildLink({ <span class="hljs-attr">parent</span>: node, <span class="hljs-attr">child</span>: htmlNode });
    });
};
</code></pre><p>Unified allows us to hook into the processing stream of our markdown files. In the first step, <code>remarkParse</code> parses our markdown file into what&#x27;s known as an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a>. It essentially takes each component of the markdown file, header, paragraph, image, and creates an object out of each. For example, here is the syntax tree for our level-two.md:</p><pre><code class="hljs language-javascript">{
  <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;root&quot;</span>,
  <span class="hljs-string">&quot;children&quot;</span>:[
     {
        <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;heading&quot;</span>,
        <span class="hljs-string">&quot;depth&quot;</span>:<span class="hljs-number">1</span>,
        <span class="hljs-string">&quot;children&quot;</span>:[
           {
              <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;text&quot;</span>,
              <span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;Level Two&quot;</span>,
           }
        ]
     },
     {
        <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;paragraph&quot;</span>,
        <span class="hljs-string">&quot;children&quot;</span>:[
           {
              <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;text&quot;</span>,
              <span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;This is our second post, we&#x27;re &quot;</span>,
           },
           {
              <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;emphasis&quot;</span>,
              <span class="hljs-string">&quot;children&quot;</span>:[
                 {
                    <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;text&quot;</span>,
                    <span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot;really&quot;</span>,
                 }
              ]
           },
           {
              <span class="hljs-string">&quot;type&quot;</span>:<span class="hljs-string">&quot;text&quot;</span>,
              <span class="hljs-string">&quot;value&quot;</span>:<span class="hljs-string">&quot; on a roll now aren&#x27;t we?&quot;</span>,
           }
        ]
     }
  ]
}
</code></pre><p>What we&#x27;re doing here is hooking in right after the markdown file is processed into an AST, plucking out elements of type <code>image</code>, then replacing their <code>url</code> property from the source-relative path to where we know the file is in our public runtime environment. Then, the parsing process finishes as usual.</p><p>Typically, such gymnastics shouldn&#x27;t be necessary. They&#x27;re only needed if we want to avoid using the static folder and have images within our markdown files. For the majority of other purposes, you&#x27;ll either just use a graphql query to pull in desired images as we showed, or you&#x27;ll just have URLs to images hosted elsewhere if you&#x27;re not stashing them locally. That being said, I don&#x27;t know about you, but I had a lot of fun learning about abstract syntax trees. 🤓</p><h2>Resimplifying with Gatsby Plugins</h2><p>So, now that we&#x27;ve really gotten into the weeds and created an entire build pipeline using Gatsby&#x27;s architecture from scratch, how about we simplify our lives? Gatsby actually has a plugin for everything we did above, so let&#x27;s remove all of our handcrafted code and swap in the relevant plugins.</p><p>Our <code>exports.sourceNodes</code> function replicates <code>gatsby-source-filesystem</code>. Our <code>exports.onCreateNode</code> function replicates <code>gatsby-transformer-remark</code>, which parses the markdown to HTML, <code>gatsby-remark-prismjs</code>, which adds syntax highlighting to code blocks, and <code>gatsby-remark-images</code>, which processes images in markdown to be used in the production build. Let&#x27;s start by installing everything we&#x27;ll need. The default starter already comes with the filesystem plugin, a few image utilities (but not remark-images) and some SEO tools. Before we do that, let&#x27;s also uninstall the packages we used to manually do some of this stuff, since many of Gatsby&#x27;s plugins use the same packages as dependencies.</p><pre><code class="hljs language-bash">$ npm uninstall rehype-prism rehype-stringify remark remark-html remark-parse remark-rehype unified unist-util-visit
$ npm install gatsby-transformer-remark gatsby-remark-prismjs gatsby-remark-images prismjs
</code></pre><p>Now, let&#x27;s configure our plugins.</p><div class="remark-code-title">gatsby-config.js</div><pre><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-comment">//…</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-comment">//…</span>
    {
      <span class="hljs-attr">resolve</span>: <span class="hljs-string">&#x27;gatsby-source-filesystem&#x27;</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;markdown-pages-images&#x27;</span>,
        <span class="hljs-attr">path</span>: <span class="hljs-string">`<span class="hljs-subst">${__dirname}</span>/content`</span>
      }
    },
    {
      <span class="hljs-attr">resolve</span>: <span class="hljs-string">&#x27;gatsby-transformer-remark&#x27;</span>,
      <span class="hljs-attr">options</span>: {
        <span class="hljs-attr">plugins</span>: [
          {
            <span class="hljs-attr">resolve</span>: <span class="hljs-string">&#x27;gatsby-remark-images&#x27;</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">maxWidth</span>: <span class="hljs-number">1000</span>
            }
          },
          <span class="hljs-string">&#x27;gatsby-remark-prismjs&#x27;</span>
        ]
      }
    }
    <span class="hljs-comment">//…</span>
  ]
};
</code></pre><p>We&#x27;re adding a configuration for <code>gatsby-source-filesystem</code> with the directory of our content. We&#x27;re also adding the <code>gatsby-transformer-remark</code> plugin, with a couple of child plugins, which are related to parsing markdown files, <code>gatsby-remark-images</code> and <code>gatsby-remark-prismjs</code>.</p><p>Next, let&#x27;s make the needed adjustments to our gatsby-node.js file. First, we can completely remove the <code>sourceNodes</code> function, since the plugins create all of our nodes for us. We also need to make a few tweaks to the <code>createPages</code> and <code>onCreateNode</code> functions.</p><div class="remark-code-title">gatsby-node.js</div><pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> { createFilePath } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gatsby-source-filesystem&#x27;</span>);

<span class="hljs-built_in">exports</span>.createPages = <span class="hljs-keyword">async</span> ({ graphql, actions }) =&gt; {
  <span class="hljs-keyword">const</span> { createPage } = actions;
  <span class="hljs-keyword">const</span> markdownPages = <span class="hljs-keyword">await</span> graphql(<span class="hljs-string">`
    query {
      allMarkdownRemark {
        edges {
          node {
            fields {
              slug
            }
          }
        }
      }
    }
  `</span>);

  markdownPages.data.allMarkdownRemark.edges.forEach(<span class="hljs-function">(<span class="hljs-params">{ node }</span>) =&gt;</span> {
    createPage({
      <span class="hljs-attr">path</span>: node.fields.slug,
      <span class="hljs-attr">component</span>: <span class="hljs-built_in">require</span>.resolve(<span class="hljs-string">&#x27;./src/templates/blog-post.js&#x27;</span>),
      <span class="hljs-attr">context</span>: {
        <span class="hljs-attr">slug</span>: node.fields.slug
      }
    });
  });
};

<span class="hljs-built_in">exports</span>.onCreateNode = <span class="hljs-keyword">async</span> ({ node, getNode, actions }) =&gt; {
  <span class="hljs-keyword">const</span> { createNodeField } = actions;

  <span class="hljs-keyword">if</span> (node.internal.type === <span class="hljs-string">&#x27;MarkdownRemark&#x27;</span>) {
    <span class="hljs-keyword">const</span> slug = createFilePath({ node, getNode });
    createNodeField({
      node,
      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;slug&#x27;</span>,
      <span class="hljs-attr">value</span>: slug
    });
  }
};
</code></pre><p>That&#x27;s the whole file now! That really cleans things up doesn&#x27;t it?! 😌 One completely new item is that in <code>onCreateNode</code> we have to create our own slug for the MardownRemark nodes. We can actually specify these in the markdown post&#x27;s <a href="https://www.gatsbyjs.org/docs/adding-markdown-pages/#frontmatter-for-metadata-in-markdown-files">frontmatter</a> if we wanted to, since MarkdownRemark gives us frontmatter parsing as a free bonus! However, if your file names are going to be consistent with your slugs, you can just create a slug field using the relative file path to make things a bit easier, and it&#x27;s also simplified by <code>gatsby-source-filesystem</code> as it provides a function to do so.</p><p>The last change we made was to change our <code>allBlogHtml</code> node names in the query to <code>allMarkdownRemark</code>. It&#x27;s important to note also that since we added the slug as a <code>field</code>, you need to access it with <code>node.fields.slug</code> rather than just <code>node.slug</code>. Finally, we just need to change the node names in our template file.</p><div class="remark-code-title">src/templates/blog-post.js</div><pre><code class="hljs language-jsx"><span class="hljs-keyword">import</span> { graphql } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;gatsby&#x27;</span>;
<span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BlogPost</span>(<span class="hljs-params">{ data }</span>) </span>{
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">dangerouslySetInnerHTML</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">__html:</span> <span class="hljs-attr">data.markdownRemark.html</span> }}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span> <span class="hljs-comment">// highlight-line</span>
  );
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> query = graphql<span class="hljs-string">`
  query($slug: String!) {
    markdownRemark(fields: { slug: { eq: $slug } }) { // highlight-line
      html
    }
  }
`</span>;
</code></pre><p>Restart Gatsby and voila! Everything is exactly as it was before, with 95% less <em>custom</em> code. However, we&#x27;ll be wise to note that all of the functionality we just removed from our own <code>gatsby-node.js</code> is now in each plugin&#x27;s own <code>gatsby-node.js</code> file.</p><p>That&#x27;s how Gatsby&#x27;s plugin system works. Plugins provide their own functionality by wrapping everything in a tidy package which contains just the Gatsby APIs they utilize. If you <a href="https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-source-filesystem/src">open the code</a> for <code>gatsby-source-filesystem</code> for example, you&#x27;ll see it also has a <code>gatsby-node.js</code> file which does what we coded ourselves (and much more, of course). When we install the plugin and add it to our configuration, the idea is it &quot;plugs in&quot; to our own project&#x27;s Gatsby build process as though we had the code in our <code>gatsby-node.js</code> file.</p><p>Likewise, if we were to make our own plugin that we wanted to reuse in other projects, or even publish publicly, we could extract the relevant code from our <code>gatsby-node.js</code> file into a <code>/plugins/my-plugin</code> folder with its own <code>package.json</code> and <code>gatsby-node.js</code> file, and we&#x27;d pretty much be ready to use it. Neat!</p><p>I created this post in order to learn Gatsby more deeply as I created this very blog! So, if you&#x27;re interested in seeing the full code as it stands at the end of this post, you can visit the relevant branches in the Github repository. The final version using our custom code is available at the <a href="https://github.com/Daynil/quests-in-code/tree/final-plugin-free">final-plugin-free</a> branch, and the final version after we swapped everything for Gatsby plugins is available at <a href="https://github.com/Daynil/quests-in-code/tree/gatsby-plugins">gatsby-plugins</a>.</p><h2>Conclusion</h2><p>So what have we learned from today&#x27;s adventure?</p><p>We took a deep dive into Gatsby&#x27;s internals, and essentially reimplemented basic functioning versions of some of Gatsby&#x27;s popular plugins. Along the way, I think we&#x27;ve certainly developed an appreciation for the complexity that is abstracted away.</p><p>However, since we didn’t shy away from this complexity initially, we now understand exactly how many of Gatsby&#x27;s key core systems operate, and we&#x27;re well equipped to understand exactly how most plugins operate, as well as how to create our own for custom use cases if needed.</p><p>For me, tools like Gatsby really come alive when you don&#x27;t just take their abstractions for granted, instead diving in head-first and really taking the time to figure out how things work and come together. Once you&#x27;ve developed a robust mental model for the foundational principles, as we have, you can take a step back and leverage the advantages of such a tool.</p><p>Well, one might think, if after swapping out our code for Gatsby plugins we ended up with exactly the same thing, what exactly did we gain other than writing less custom code?</p><p>As you may have noticed, our implementations of the plugin were very basic and naïve. We wouldn&#x27;t want to use code like that in production. Many edge cases are not addressed, and we only built it to function exactly how we were currently trying to use it.</p><p>Rather than having to build production-ready code for every single use case, we can utilize some of Gatsby&#x27;s existing plugins to save us a ton of time and energy, and we get a lot of additional bonuses. You may have noticed, for example, that while it is loading, our cat image now holds its position in the page, and blurs in when we open our <code>level-one</code> blog post. Super cool! These are clearly non-trivial things to accomplish, but we get a robust mechanism for doing them for free with our plugins.</p><p>If we ever run into the limitations of existing plugins, or we need to source data from new places, we now know exactly where to start. In the same spirit as this blog post, if you ever feel you don&#x27;t understand something about a plugin, or it seems not to work right for some reason, don&#x27;t be shy about diving into the plugin&#x27;s codebase. You know how it should work now!</p><p>With that, it&#x27;s onward to new adventures!</p></span></div><a href="https://twitter.com/share?url=https://questsincode.com/posts/gatsby-blog-from-scratch/&amp;text=“Gatsby Blog From Scratch: An In-depth Guide to Starting with Gatsby”, a post from Danny Libin.&amp;via=Dayn1l" target="_blank" class="flex flex-row mt-12"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="text-dblue-500 hover:text-dblue-300 transition-colors ease-in-out duration-300 w-24" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg><span class="ml-4 p-4 bg-dblue-200 dk:bg-dblue-800 text-dblue-800 dk:text-dblue-200 text-2xl rounded-md">Found this article useful? Click to share, discuss and spread the word!! 🎉</span></a><h2>Webmentions (<span class="border-b-2 border-dblue-500 text-gray-900 dk:text-gray-300 dk-hover:text-dblue-500 hover:text-dblue-500 hover:border-transparent transition duration-200 ease-in-out"><a href="https://indieweb.org/Webmention" rel="noopener" target="_blank" class="text-lg border-b-0">❔</a></span>)</h2><div>No comments yet.<!-- --> <span class="border-b-2 border-dblue-500 text-gray-900 dk:text-gray-300 dk-hover:text-dblue-500 hover:text-dblue-500 hover:border-transparent transition duration-200 ease-in-out"><a href="https://twitter.com/share?url=https://questsincode.com/posts/gatsby-blog-from-scratch/&amp;text=“Gatsby Blog From Scratch: An In-depth Guide to Starting with Gatsby”, a post from Danny Libin.&amp;via=Dayn1l" rel="noopener" target="_blank">Start the conversation!</a></span> <!-- -->Your post will show up here.</div></div></main><footer class="text-gray-600 mt-32 pb-12">© <!-- -->2020<!-- --> Quests In Code. All Rights Reserved. Created by<!-- --> <span class="border-b-2 border-dblue-500 text-gray-900 dk:text-gray-300 dk-hover:text-dblue-500 hover:text-dblue-500 hover:border-transparent transition duration-200 ease-in-out"><a href="https://dlibin.net" rel="noopener" target="_blank">Danny Libin</a></span>.</footer></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"\"use strict\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i \u003c arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i \u003c sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i \u003c sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) \u003e= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\n\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Are you the type of person that likes to poke around under the hood before getting started with something new? Me too!\"), mdx(\"p\", null, \"If you want to get started with Gatsby quickly, Gatsby has excellent \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gatsbyjs.org/docs/\"\n  }), \"documentation\"), \". Have a look at their quick start, pick a nice starter template, create your app with the starter template, and you're off to the races!\"), mdx(\"p\", null, \"However, I've never been one that takes complexity for granted. To be sure, there is a reason for the complexity Gatsby introduces, but you truly need to understand it in order to appreciate what it brings to the table. Complexity is a trade-off, so you really need to consider why you would want to use something like Gatsby over, say, a simple site with just HTML and some CSS and javascript sprinkled in as needed.\"), mdx(\"h2\", null, \"Plan to Learn Gatsby In Depth\"), mdx(\"p\", null, \"Gatsby has a lot of moving pieces, particularly when you start adding plugins, and it's easy to get overwhelmed as you inevitably start customizing to suite your sites and preferences. Plugins are an extremely useful tool in Gatsby, and the community that has developed around it is \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gatsbyjs.org/plugins/\"\n  }), \"quite rich\"), \".\"), mdx(\"p\", null, \"However, the best way to understand Gatsby is starting completely bare, with no plugins or starters, even those developed by the Gatsby team. Eventually, those tools will add much convenience and velocity to your development. But if you want to understand everything that's going on, its nice to start from scratch and work your way up.\"), mdx(\"p\", null, \"Clearly there are far too many plugins to break each one down and understand them all in one shot before you even start using Gatsby, and that would be counter to the purpose of Gatsby. But there are a few core features of Gatsby which, if you can dig into them deeply and understand them at the lowest level, you will have a solid foundation upon which to draw from in your work with Gatsby.\"), mdx(\"p\", null, \"After our exploration of Gatsby today, we'll:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand how Gatsby's build process works\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Understand how most plugins work and how they hook into Gatsby\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Have a clear vision for building our own plugins or extensions when we need them\")), mdx(\"p\", null, \"The three core features that most websites will be utilizing in Gatsby that we'll look to dig into are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sourcing external data for consumption in Gatsby\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Passing data to components to programmatically create pages\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Plugging into Gatsby's data management layer, GraphQL\")), mdx(\"p\", null, \"Once we manually implement a basic functioning version of all of these, we'll have an appreciation for the simplicity that Gatsby's plugin architecture brings and we'll swap out our code for the plugins that do the same thing and take advantage of the many performance improvements Gatsby offers.\"), mdx(\"h2\", null, \"What are we building?\"), mdx(\"p\", null, \"For today's adventure, we'll be building\\u2026this very blog! A blog is among the most common use cases for a static site generator, so it's a great place to start learning about Gatsby. I chose Gatsby for this site (after some substantially extensive, yet characteristic, angst about whether to use a CMS like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://wordpress.org/\"\n  }), \"WordPress\"), \" or any of a large number of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.staticgen.com/\"\n  }), \"other static site generators\"), \"\\u2026) because I wanted to keep server costs to a minimum, as well as leverage my existing knowledge of javascript and React to add many bits of dynamism to the site that would typically be more challenging with a CMS or a static site generator that uses a different programming language.\"), mdx(\"p\", null, \"Gatsby's documentation has a great summary of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gatsbyjs.org/features/cms/\"\n  }), \"why you would use it over a traditional CMS\"), \", or \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gatsbyjs.org/features/jamstack/\"\n  }), \"other static site generators\"), \".\"), mdx(\"p\", null, \"In the end, they all achieve very similar things in different ways, so the choice is personal. However, after some tinkering with various options, I've found Gatsby to be the best for the most important reason: it's the most fun to use!\"), mdx(\"p\", null, \"I've played a bit with Gatsby in my experimentation, but I don't feel that I've learned it enough to be satisfied with my foundational knowledge. So, this post will be an exploration of learning Gatsby in depth by building a thing from scratch!\"), mdx(\"p\", null, \"The final version using our custom code is available at the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/Daynil/quests-in-code/tree/final-plugin-free\"\n  }), \"final-plugin-free\"), \" branch in the Github repository for this blog, if you ever want to see the full picture of the code.\"), mdx(\"h2\", null, \"Starting From Scratch\"), mdx(\"p\", null, \"To get started, let's use the gatsby CLI to generate the default blank starter.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-bash\"\n  }), \"$ npm install -g gatsby-cli\\n$ gatsby new quests-in-code\\n\")), mdx(\"p\", null, \"The Gatsby CLI allows you to pass an optional parameter called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"starter-url\"), \", which can provide many useful defaults such as plugins for parsing markdown, for using typescript, etc. However, for our learning purposes we want to start with the minimum available option. If you do not pass anything for the starter-url, the default blank starter used, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-starter-default\"), \". You can also pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-starter-default\"), \" as the parameter, but that does the same thing as omitting it. Once Gatsby finishes installing everything, you'll see a success message. Let's explore what Gatsby has scaffolded out for us.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-bash\"\n  }), \"$ \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"cd\"), \" quests-in-code\\n$ code .\\n$ gatsby develop\\n\")), mdx(\"p\", null, \"What we see is a very simple starter application with a few things already in place. We have 3 pages, a few components to be used within pages, and a couple of images.\"), mdx(\"p\", null, \"If you open up \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-config.js\"), \", you'll notice there are actually already a number of plugins included even in this default blank starter:\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-config.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"module\"), \".exports = {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"siteMetadata\"), \": {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"title\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`Gatsby Default Starter`\"), \",\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"description\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`Kick off your next, great Gatsby project with this default starter. This barebones starter ships with the main Gatsby configuration files you might need.`\"), \",\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"author\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`@gatsbyjs`\"), \"\\n  },\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"plugins\"), \": [\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`gatsby-plugin-react-helmet`\"), \",\\n    {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"resolve\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`gatsby-source-filesystem`\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"options\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"name\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`images`\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${__dirname}\"), \"/src/images`\"), \"\\n      }\\n    },\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`gatsby-transformer-sharp`\"), \",\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`gatsby-plugin-sharp`\"), \",\\n    {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"resolve\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`gatsby-plugin-manifest`\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"options\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"name\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`gatsby-starter-default`\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"short_name\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`starter`\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"start_url\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`/`\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"background_color\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`#663399`\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"theme_color\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`#663399`\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"display\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`minimal-ui`\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"icon\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`src/images/gatsby-icon.png`\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// This path is relative to the root of the site.\"), \"\\n      }\\n    }\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// this (optional) plugin enables Progressive Web App + Offline functionality\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// To learn more, visit: https://gatsby.dev/offline\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// `gatsby-plugin-offline`,\"), \"\\n  ]\\n};\\n\")), mdx(\"p\", null, \"We will be needing all of these eventually, but we will start building out our blog without them so we can understand what they are for.\"), mdx(\"p\", null, \"First, let's create a simple page ourselves just to make sure we understand the very basics. Create a file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog-post.js\"), \" in the pages folder. Gatsby automatically builds a page with the URL as the file name for files in this folder. Throw an image called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat-1.jpg\"), \" into the images folder so we can explore how to use our own images.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"src/pages/blog-post.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-jsx\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"import\"), \" React \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"from\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'react'\"), \";\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"import\"), \" Cat1 \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"from\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'../images/cat-1.jpg'\"), \";\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"default\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"BlogPost\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  })), \") \"), \"{\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \" (\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"xml\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\"), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"h1\"), \"\u003e\"), \"Level One\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"h1\"), \"\u003e\"), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"p\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"style\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"{{\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"color:\"), \" '#\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"718096\"), \"', \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"fontSize:\"), \" '\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"18px\"), \"' }}\u003e\"), \"March 8th, 2020\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"p\"), \"\u003e\"), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"p\"), \"\u003e\"), \"\\n        This is the first post in the blog, currently just a placeholder but we\\n        will soon add lots of \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"i\"), \"\u003e\"), \"awesome\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"i\"), \"\u003e\"), \" meaningful content.\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"p\"), \"\u003e\"), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"img\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"src\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"{Cat1}\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"width\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"700px\\\"\"), \" /\u003e\"), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\")), \"\\n  );\\n}\\n\")), mdx(\"p\", null, \"Now, navigate to http://localhost:8000/blog-post and you will see our first blog post show up as expected.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./level-one-post.png\",\n    \"alt\": \"Blogpost built in React screenshot\"\n  }))), mdx(\"p\", null, \"Awesome, that was easy enough right?!\"), mdx(\"p\", null, \"Of course, as simple as Gatsby makes this, we don't want to have to take the time to write all of our blog posts in raw JSX. There are several ways to author content in a more user friendly way, then use Gatsby to create pages out of it. One of the most popular ways is using a content management system, such as \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.netlifycms.org/\"\n  }), \"Netlify CMS\"), \". Another popular and simple way, which we will use, is markdown files.\"), mdx(\"h2\", null, \"Using Markdown\"), mdx(\"p\", null, \"Let's create a couple of super simple markdown placeholders for our first 2 posts. We'll create a folder called content in the base directory with two markdown files, them move our cat image here as well. Here's what we will have as of now:\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./markdown-folder.png\",\n    \"alt\": \"Gatsby content folder structure screenshot\"\n  }))), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"content/level-one.md\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-markdown\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-section\"\n  }), \"# Level One\"), \"\\n\\nThis is the first post in the blog, currently just a placeholder but we will soon add lots of \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-emphasis\"\n  }), \"_awesome_\"), \" meaningful content.\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-section\"\n  }), \"### This came from a markdown file!\"), \"\\n\\n![\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"Funny Cat\"), \"](\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-link\"\n  }), \"/cat-1.jpg\"), \")\\n\")), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"content/level-two.md\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-markdown\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-section\"\n  }), \"# Level Two\"), \"\\n\\nThis is our second post, we're \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-emphasis\"\n  }), \"_really_\"), \" on a roll now aren't we?\\n\")), mdx(\"p\", null, \"Great, we've got some posts written! But now what, how do we see them in the browser?\"), mdx(\"p\", null, \"This is where our adventure really begins to get interesting!\"), mdx(\"p\", null, \"Right now, Gatsby doesn't know anything about our markdown files. We need to tell Gatsby how to process and display these markdown files. Our current \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog-post.js\"), \" page file just displays some hard-coded strings and we're not creating any pages for the markdown files.\"), mdx(\"p\", null, \"Let's start fix this by teaching Gatsby how to parse a markdown file into HTML so that we can use it in our site. First, let's install a markdown parser. There are several options, but we'll use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://remark.js.org/\"\n  }), \"remark\"), \" since that's what Gatsby's main markdown plugin uses, which we will switch to once we understand what it is doing under the hood.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-bash\"\n  }), \"$ npm install remark remark-html\\n\")), mdx(\"p\", null, \"Gatsby has a special file called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" which is run once when your site is being built. We can use this file to parse the markdown files. Let's start by just parsing our first markdown post and logging it out to the console.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" remark = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'remark'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" html = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'remark-html'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" fs = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'fs'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".createPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" () =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" post1 = fs.readFileSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./content/level-one.md'\"), \"));\\n\\n  remark()\\n    .use(html)\\n    .process(post1, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"err, file\"), \") \"), \"{\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (err) \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".error(err);\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".log(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file));\\n    });\\n};\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// Output:\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// \u003ch1\u003eLevel One\u003c/h1\u003e\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// \u003cp\u003eThis is the first post in the blog, currently just a placeholder but we will soon add lots of \u003cem\u003eawesome\u003c/em\u003e meaningful content.\u003c/p\u003e\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// \u003cp\u003e\u003cimg src=\\\"/cat-1.jpg\\\" alt=\\\"Funny Cat\\\"\u003e\u003c/p\u003e\"), \"\\n\")), mdx(\"p\", null, \"Great! So now we've read in our markdown file into memory with node's readFileSync API, then parsed it to HTML using remark. Now we need a way to display this parsed HTML with Gatsby.\"), mdx(\"h2\", null, \"Programmatic Page Generation\"), mdx(\"p\", null, \"In Gatsby, you create page templates in order to programmatically generate pages. So, let's move our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog-post.js\"), \" component to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/templates\"), \" (and remove the hard coded image if you moved it to the content folder earlier). Now that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blog-post.js\"), \" is in templates and not pages, Gatsby will no longer automatically generate a page for it. Gatsby expects us to explain how to create this page programmatically, so let's do that.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" remark = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'remark'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" html = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'remark-html'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" fs = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'fs'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".createPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" () =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" post1 = fs.readFileSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./content/level-one.md'\"), \"));\\n\\n  remark()\\n    .use(html)\\n    .process(post1, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"err, file\"), \") \"), \"{\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (err) \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".error(err);\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".log(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file));\\n      createPage({\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'/blog-post'\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"component\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./src/templates/blog-post.js'\"), \")\\n      });\\n    });\\n};\\n\")), mdx(\"p\", null, \"Now restart the development server and go back to http://localhost:8000/blog-post and you'll see that it still works. Ok, what was the point of that? We've just imperatively done what Gatsby did for us automatically by convention when this file was in the pages. Well, this is where the power of Gatsby comes in. Now that we can tap into Gatsby's build system, we can use whatever data we want and map it to page templates. We can make use of our parsed markdown file by passing it to our template using createPage's context property.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// \\u2026\"), \"\\nremark()\\n  .use(html)\\n  .process(post1, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"err, file\"), \") \"), \"{\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (err) \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".error(err);\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".log(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file));\\n    createPage({\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'/blog-post'\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"component\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./src/templates/blog-post.js'\"), \"),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"context\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"post\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file)\\n      }\\n    });\\n  });\\n\")), mdx(\"p\", null, \"Now our blog-post template component has access to the context via the pageContext prop, so let's replace the hard-coded post in blog-post.js with dynamically set HTML from the markdown.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"src/templates/blog-post.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-jsx\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"import\"), \" React \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"from\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'react'\"), \";\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"default\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"BlogPost\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ pageContext }\"), \") \"), \"{\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"xml\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"dangerouslySetInnerHTML\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"{{\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"__html:\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"pageContext.post\"), \" }}\u003e\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\")), \";\\n}\\n\")), mdx(\"p\", null, \"Restart your development server and go back to our blog post URL. It works! However, there is one small issue - the image doesn't load, what gives?! The path is set correctly, but Gatsby doesn't know where to look for the image, since we have only told Gatsby how to process markdown files, not images.\"), mdx(\"p\", null, \"When you pass a relative path, by default Gatsby looks for images at the root static folder: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"static/\"), \". If we move our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat-1.jpg\"), \" from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"content/cat-1.jpg\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"static/cat-1.jpg\"), \" and refresh the development server, the image will show up as expected. This isn't ideal, since we're creating a conceptual gap between where a file's relative path is in your development environment's folder structure versus where it ends up in Gatsby's runtime environment.\"), mdx(\"p\", null, \"Gatsby's plugins solve this by registering the relative paths and mapping them to the static folder in the output directory. For example, you'll see with one of the default images from the starter, in the source directory, it lives under \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/images/gatsby-astronaut.png\"), \", but upon running \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$ gatsby build\"), \", the image gets moved to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public/static/{generatedId}/{generatedId}/gatsby-astronaut.png\"), \". Gatsby's plugin also generates different image sizes for each image, which is what the various subfolders for each image contain.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./astronaut-src.png\",\n    \"alt\": \"Gatsby source image folder structure\"\n  }))), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./astronaut-build.png\",\n    \"alt\": \"Gatsby public static build folder structure\"\n  }))), mdx(\"p\", null, \"We'll also note that once we put our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat-1.jpg\"), \" into the static folder, during the build Gatsby puts it in the root directory, not the static directory, so we can access it directly using what appears to be a relative path: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/cat-1.jpg\"), \".\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./cat-build.png\",\n    \"alt\": \"Gatsby source static build folder structure\"\n  }))), mdx(\"p\", null, \"Essentially, we haven't told Gatsby anything about how to process images, but its build process just moves files in the static directory as-is to the root public directory. We can allow the use of more logical relative paths imperatively by hooking into Gatsby's build system and moving the files into the static folder at build time or moving it to the appropriate folder in the built directory. However, let's just leave it in the static folder for now so we can focus on the markdown files first.\"), mdx(\"p\", null, \"Our blog-post template is now fully dynamic and is the only thing we need to render all of our markdown files. Let's prove this out by creating another page for our other post. The only thing we need to change is the path, creating a unique slug for each post.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// \\u2026\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".createPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({ actions }) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createPage } = actions;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" contentDir = fs.readdirSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./content/'\"), \");\\n\\n  contentDir.forEach(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"mdFilePath\"), \" =\u003e\"), \" {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" post = fs.readFileSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`./content/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath}\"), \"`\"), \"));\\n\\n    remark()\\n      .use(html)\\n      .process(post, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"err, file\"), \") \"), \"{\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (err) \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".error(err);\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".log(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file));\\n        createPage({\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath.replace(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-regexp\"\n  }), \"/\\\\.[^/.]+$/\"), \", \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"''\"), \")}\"), \"`\"), \",\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"component\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./src/templates/blog-post.js'\"), \"),\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"context\"), \": {\\n            \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"post\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file)\\n          }\\n        });\\n      });\\n  });\\n};\\n\")), mdx(\"p\", null, \"Now refresh the development server, and both of our posts will be available at the URLs corresponding to their markdown file name: http://localhost:8000/level-one and http://localhost:8000/level-two. Neat!\"), mdx(\"h2\", null, \"Code Block Syntax Highlighting\"), mdx(\"p\", null, \"Now, given that we're coders, we're obviously going to want to be able to utilize syntax highlighted code in our blog to show off our cool code snippets right? Of course, silly question. So let's add a markdown file with some code and see how it looks with our current setup.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"content/level-three.md\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-markdown\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-section\"\n  }), \"# Level Three\"), \"\\n\\nThis is a really informative post with a really fancy code snippet.\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-code\"\n  }), \"```javascript\\nconst pluckDeep = key =\u003e obj =\u003e\\n  key.split('.').reduce((accum, key) =\u003e accum[key], obj);\\n\\nconst compose = (...fns) =\u003e res =\u003e\\n  fns.reduce((accum, next) =\u003e next(accum), res);\\n\\nconst unfold = (f, seed) =\u003e {\\n  const go = (f, seed, acc) =\u003e {\\n    const res = f(seed);\\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc;\\n  };\\n  return go(f, seed, []);\\n};\\n```\"), \"\\n\")), mdx(\"p\", null, \"Navigate to our new /level-three page URL in the browser and you'll see that we have a nice code block with our code, but no syntax highlighting. That may work fine for Medium (\\uD83D\\uDE0F) but we're much cooler than that, so let's add it! First, we need to install a syntax highlighter. However, we also need to install a few additional packages as well to help us with this new parsing task. Syntax highlighting code in markdown is more complex than just turning it straight into HTML since we now have to tokenize individual characters and highlight them appropriately depending on the language. To achieve this, we can use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://prismjs.com/\"\n  }), \"PrismJS\"), \" and a few helpers.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-bash\"\n  }), \"$ npm install prismjs unified remark-parse remark-rehype rehype-prism rehype-stringify\\n\")), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" unified = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'unified'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" remarkParse = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'remark-parse'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" remarkRehype = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'remark-rehype'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" rehypePrism = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'rehype-prism'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" rehypeStringify = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'rehype-stringify'\"), \");\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" fs = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'fs'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".createPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({ actions }) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createPage } = actions;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" contentDir = fs.readdirSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./content/'\"), \");\\n\\n  contentDir.forEach(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"mdFilePath\"), \" =\u003e\"), \" {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" post = fs.readFileSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`./content/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath}\"), \"`\"), \"));\\n\\n    unified()\\n      .use(remarkParse)\\n      .use(remarkRehype)\\n      .use(rehypePrism)\\n      .use(rehypeStringify)\\n      .process(post, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"err, file\"), \") \"), \"{\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (err) \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".error(err);\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".log(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file));\\n        createPage({\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath.replace(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-regexp\"\n  }), \"/\\\\.[^/.]+$/\"), \", \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"''\"), \")}\"), \"`\"), \",\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"component\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./src/templates/blog-post.js'\"), \"),\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"context\"), \": {\\n            \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"post\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file)\\n          }\\n        });\\n      });\\n  });\\n};\\n\")), mdx(\"p\", null, \"Here we're parsing our markdown into tokens, using prism to apply the appropriate classes to each token, then turning it into HTML. However, if you refresh now, you'll see the syntax is still not highlighted. We've inserted span elements with the correct classes to highlight each token of code, but we don't have any CSS classes set up yet. Let's take one of Prism's default themes, tomorrow night, and use that. You can insert styles globally in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-browser.js\"), \".\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-browser.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'prismjs/themes/prism-tomorrow.css'\"), \");\\n\")), mdx(\"p\", null, \"Restart Gatsby and you'll see the syntax is now highlighted!\"), mdx(\"h2\", null, \"Bringing it together with GraphQL\"), mdx(\"p\", null, \"We've now got the skeleton of a fully functioning technical blog. However, as we've seen with our problem with relative image paths, handling the data can get a bit hairy. Gatsby helps simplify and streamline this process by allowing each data source to register its contents in its GraphQL layer. Once registered, you can issue concise GraphQL queries to get just the data you need for each page, using the same syntax regardless of the source of the data.\"), mdx(\"p\", null, \"Let's start by loading our markdown file information into GraphQL.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { slash } = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby-core-utils'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".sourceNodes = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ actions, createNodeId, createContentDigest }\"), \") =\u003e\"), \" {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createNode } = actions;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" contentDir = fs.readdirSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./content/'\"), \");\\n\\n  contentDir.forEach(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"mdFilePath\"), \" =\u003e\"), \" {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" nodeData = {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"absolutePath\"), \": slash(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`./content/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath}\"), \"`\"), \")),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"relativePath\"), \": mdFilePath\\n    };\\n\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" nodeMetaData = {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"id\"), \": createNodeId(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`id-\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath}\"), \"`\"), \"),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"parent\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-literal\"\n  }), \"null\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"children\"), \": [],\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"internal\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"type\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'BlogMDFile'\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"mediaType\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'text/markdown'\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"contentDigest\"), \": createContentDigest(nodeData)\\n      }\\n    };\\n\\n    createNode(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"Object\"), \".assign({}, nodeData, nodeMetaData));\\n  });\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \";\\n};\\n\")), mdx(\"p\", null, \"Instead of just looping through each file, reading it, and parsing it all in one step, we're breaking it up into two pieces. Gatsby has the concept of \\\"source\\\" plugins, which load in data from a given source, and a \\\"transformer\\\" plugin, which converts data from one format to another. This level of modularity allows you to grab data from novel \\\"sources\\\" while still leveraging existing transformer plugs.\"), mdx(\"p\", null, \"Let's say you have your markdown files hosted on some remote server for which there isn't a plugin yet. You can create a source, like we did above, to load the content in. Because you specified it was of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"text/markdown\"), \" in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"internal.mediaType\"), \" metadata, any available markdown transformer plugin can subsequently parse your data for this source, without knowing anything about how to get data from your novel source!\"), mdx(\"p\", null, \"So we've just built the \\\"source\\\" portion. In the case of local filesystem sources, we don't actually need to load the raw data in unless we'll be using it. Our raw data is markdown, which we'll need to parse to HTML before we use it, so our source is just a pointer to the file in the form of its absolute path. If you were actually creating a plugin, Gatsby provides two options to handle loading in data from source.\"), mdx(\"p\", null, \"The simplest option, which most sources will use, is to just load your data into the node object itself. So if you had a nice bit of structured of JSON from your source, you would just add it to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodeData\"), \" object, similar to what we did above. If you had content that is very large and could be lazy loaded, you could define a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loadNodeContent\"), \" function for the node, which consumers can use to load the data in only when it's requested.\"), mdx(\"p\", null, \"This is exactly what gatsby-source-filesystem does. In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"nodeData\"), \" object, it just points to the file path as we have, and provides additional metadata, such as extension, size, etc. Then, it defines a the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"loadNodeContent\"), \" function to specify how to read the data for consumers, which for a file on the local system could just be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fs.readFile(node.absolutePath)\"), \". We'll do something very similar.\"), mdx(\"p\", null, \"Gatsby's development server exposes an extremely useful interactive in-browser GraphQL IDE (integrated development environment) called GraphiQL, which shows you all of the data loaded into it. Let's open it and find our newly created nodes. By convention, they are under the name of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"internal.type\"), \" that you assigned to the node when you made it, in our case \\\"BlogMDFile\\\". We actually have two versions here, \\\"allBlogMdFile\\\" and \\\"blogMdFile\\\". They expose the same information, but as expected, the all version just shows all the nodes of the type while the other allows you to filter for individual ones.\"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"./graphiql.png\",\n    \"alt\": \"Gatsby GraphiQL in-browser query exploration tool\"\n  }))), mdx(\"p\", null, \"Great! Now that we've got our markdown files \\\"sourced\\\" into the GraphQL layer, we're going to use the information from these newly created nodes and create the \\\"transformer\\\" portion of our plugin, which will take the files and parse them, then load them into GraphQL as well.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".onCreateNode = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({\\n  node,\\n  actions,\\n  createNodeId,\\n  createContentDigest\\n}) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createNode, createParentChildLink } = actions;\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (node.internal.mediaType !== \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'text/markdown'\"), \") \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \";\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" content = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"await\"), \" fs.readFileSync(node.absolutePath);\\n  unified()\\n    .use(remarkParse)\\n    .use(remarkRehype)\\n    .use(rehypePrism)\\n    .use(rehypeStringify)\\n    .process(content, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"err, file\"), \") \"), \"{\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (err) \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".error(err);\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".log(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file));\\n\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" htmlNodeData = {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"html\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file),\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"slug\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${node.relativePath.replace(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-regexp\"\n  }), \"/\\\\.[^/.]+$/\"), \", \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"''\"), \")}\"), \"`\"), \"\\n      };\\n\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" htmlNodeMetaData = {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"id\"), \": createNodeId(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`id-html-\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${node.absolutePath}\"), \"`\"), \"),\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"parent\"), \": node.id,\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"children\"), \": [],\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"internal\"), \": {\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"type\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'BlogHTML'\"), \",\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"mediaType\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'text/html'\"), \",\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"contentDigest\"), \": createContentDigest(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file))\\n        }\\n      };\\n\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" htmlNode = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"Object\"), \".assign({}, htmlNodeData, htmlNodeMetaData);\\n\\n      createNode(htmlNode);\\n      createParentChildLink({ \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"parent\"), \": node, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"child\"), \": htmlNode });\\n    });\\n};\\n\")), mdx(\"p\", null, \"Here we're just hooking into Gatsby's build process, looking for when nodes of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"text/markdown\"), \" are created, then using our existing code to parse that node's data to HTML and create a new node with it. There's no real difference here versus what we did back when we first created the code that parses our markdown, we've just split it up and loaded it into GraphQL.\"), mdx(\"p\", null, \"Great, so now we've got our parsed HTML again, but now it's loaded into the GraphQL layer. Now we can query that data the same way we would query anything in Gatsby. Let's rewrite our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createPages\"), \" function to leverage GraphQL.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".createPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({ graphql, actions }) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createPage } = actions;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" markdownPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"await\"), \" graphql(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\\n    query {\\n      allBlogHtml {\\n        edges {\\n          node {\\n            slug\\n          }\\n        }\\n      }\\n    }\\n  `\"), \");\\n\\n  markdownPages.data.allBlogHtml.edges.forEach(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ node }\"), \") =\u003e\"), \" {\\n    createPage({\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": node.slug,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"component\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./src/templates/blog-post.js'\"), \"),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"context\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"slug\"), \": node.slug\\n      }\\n    });\\n  });\\n};\\n\")), mdx(\"p\", null, \"Awesome, that dramatically simplifies our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createPages\"), \" function. Now we're just querying grabbing the slug for each post and create a page for it. However, you'll note we're no longer passing the parsed HTML in the context. Well, how will our template know what to render?! Well, that's the beauty of GraphQL. We can now colocate the query for the data the template needs with the template itself! The only thing we need when we're actually creating the pages is the slug.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"src/templates/blog-past.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-jsx\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"import\"), \" { graphql } \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"from\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby'\"), \";\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"import\"), \" React \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"from\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'react'\"), \";\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"default\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"BlogPost\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ data }\"), \") \"), \"{\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"xml\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"dangerouslySetInnerHTML\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"{{\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"__html:\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"data.blogHtml.html\"), \" }}\u003e\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\")), \";\\n}\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" query = graphql\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\\n  query($slug: String!) {\\n    blogHtml(slug: { eq: $slug }) {\\n      html\\n    }\\n  }\\n`\"), \";\\n\")), mdx(\"p\", null, \"We've passed the slug in as context, and when a page is created for a template, you can use keys from the context object to match up with arguments in the GraphQL page query. Variables in GraphQL are prefaced with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$\"), \", so here passing a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"slug\"), \" property into the context will pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"$slug\"), \" into the query, and we've just specified it is of type string. The results of the query are now available in the props of the component under the aptly named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"data\"), \" property by convention. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pageContext\"), \" is also still available as a separate object in the component's props if it is needed (e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"BlogPost({ data, context })\"), \"), but in our case, the slug was only needed for the query.\"), mdx(\"p\", null, \"Restart Gatsby and you'll see that our pages are once again available as they were, success!!\"), mdx(\"h2\", null, \"Dealing with Images\"), mdx(\"p\", null, \"One last thing that we need to do is actually move our sourced files from our source directory to somewhere we can access them in the public build directory. This isn't strictly necessary for the markdown files, since we've already parsed all the information out of them into a string on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"blogHtml.html\"), \" graphql node. However, remember our problem with the images? Here's where we fix that problem!\"), mdx(\"p\", null, \"Recall that we temporarily dealt with the issue of our cat image not being available in the public directory by just moving it to Gatsby's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/static\"), \" folder. From there, Gatsby just dumps all the files into the root \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public\"), \" folder at build time, where we can use them in the runtime environment. The issue we had was the logical disconnect between where files are in the development \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src\"), \" directory versus where they end up in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public\"), \" directory at runtime.\"), mdx(\"p\", null, \"Let's deal with this in a way that lets us organize our files logically. We'll move the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cat-1.jpg\"), \" back to the content folder, alongside our markdown posts, as we originally had it. Also, we'll go into our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"level-one.md\"), \" and make a slight adjustment to the image url to make it relative again, changing \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"![Funny Cat](/cat-1.jpg)\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"![Funny Cat](./cat-1.jpg)\"), \".\"), mdx(\"p\", null, \"Next, we need to do a few new things in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sourceNodes\"), \" function. First, create a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"publicURL\"), \" field in node data which will tell us where each file we process will sit in the public directory. We'll put all of our files into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"public/static\"), \" directory. Now that we're processing images in addition to markdown files, we'll need to set our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"internal.mediaType\"), \" to correctly reflect the file type, otherwise our transformer will have a cow trying to parse an jpeg file into HTML. Then, we'll copy each file to its public location, so it will be accessible to our blog posts at runtime.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" path = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'path'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".sourceNodes = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ actions, createNodeId, createContentDigest }\"), \") =\u003e\"), \" {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createNode } = actions;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" contentDir = fs.readdirSync(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./content/'\"), \");\\n\\n  contentDir.forEach(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"mdFilePath\"), \" =\u003e\"), \" {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" nodeData = {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"absolutePath\"), \": slash(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`./content/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath}\"), \"`\"), \")),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"relativePath\"), \": mdFilePath,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"publicURL\"), \": slash(\\n        path.resolve(process.cwd(), \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'public'\"), \", \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'static'\"), \", mdFilePath)\\n      ),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"publicRelativePath\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`/static/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath}\"), \"`\"), \"\\n    };\\n\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" extension = mdFilePath.split(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'.'\"), \")[\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"1\"), \"];\\n\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" nodeMetaData = {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"id\"), \": createNodeId(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`id-\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${mdFilePath}\"), \"`\"), \"),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"parent\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-literal\"\n  }), \"null\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"children\"), \": [],\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"internal\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"type\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'BlogMDFile'\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"mediaType\"), \": extension === \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'md'\"), \" ? \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'text/markdown'\"), \" : \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'image/jpeg'\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"contentDigest\"), \": createContentDigest(nodeData)\\n      }\\n    };\\n\\n    fs.copyFileSync(nodeData.absolutePath, nodeData.publicURL);\\n\\n    createNode(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"Object\"), \".assign({}, nodeData, nodeMetaData));\\n  });\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \";\\n};\\n\")), mdx(\"p\", null, \"Now, we can access our images in runtime. If we wanted to use our cat image directly in our JSX, we could write a static or page query to grab the url. For example, we can create the following query in our blog post template to pull in the public URL:\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"src/templates/blog-post.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-jsx\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"default\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"BlogPost\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ data }\"), \") \"), \"{\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \" (\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"xml\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\"), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"img\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"src\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"{data.blogMdFile.publicRelativePath}\"), \" /\u003e\"), \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"dangerouslySetInnerHTML\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"{{\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"__html:\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"data.blogHtml.html\"), \" }}\u003e\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\"), \";\\n    \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\")), \"\\n  );\\n}\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" query = graphql\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\\n  query($slug: String!) {\\n    blogHtml(slug: { eq: $slug }) {\\n      html\\n    }\\n    blogMdFile(relativePath: { eq: \\\"cat-1.jpg\\\" }) {\\n      publicRelativePath\\n    }\\n  }\\n`\"), \";\\n\")), mdx(\"p\", null, \"In our case, the relative path is the same as the file name since the image is sitting in the same folder as the rest of our content, so we can just search by the file name. We grab the public relative path we created in our node for our files, and since we moved the image during the build to the static directory, we can now reference the files.\"), mdx(\"p\", null, \"However, the astute reader will note that we've clearly not solved the problem we set out to yet. In our markdown file, we referenced the image as relative to the source environment markdown file's location \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"./cat-1.jpg\"), \". But we moved the files to a static folder, so it still won't resolve properly in the runtime environment. Since our file is written in markdown, we can't do any fancy graphql querying to retrieve files, nor would we want to. We just want to type a relative string with the file name in our blog post markdown and have it resolve properly. What do??\"), mdx(\"p\", null, \"This piece is just a bit trickier, but still worth exploring to make sure we've fully wrapped our heads around everything going on under the hood. The complexity is that the markdown file to which the image is relative no longer exists as far as the runtime environment is concerned - it's parsed into an HTML fragment, which we insert into our template. So our only remaining choice is to fake it, hot-swapping the original relative URL with the public directory we know the file is in.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" visit = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'unist-util-visit'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".onCreateNode = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({\\n  node,\\n  actions,\\n  createNodeId,\\n  createContentDigest\\n}) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createNode, createParentChildLink } = actions;\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (node.internal.mediaType !== \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'text/markdown'\"), \") \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \";\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" content = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"await\"), \" fs.readFileSync(node.absolutePath);\\n  unified()\\n    .use(remarkParse)\\n    .use(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), \"() =\u003e\"), \" {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"transformer\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"tree, file\"), \") \"), \"{\\n        visit(tree, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'image'\"), \", \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"node\"), \") \"), \"{\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" imageName = node.url.split(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./'\"), \")[\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"1\"), \"];\\n          node.url = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`/static/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${imageName}\"), \"`\"), \";\\n        });\\n      };\\n    })\\n    .use(remarkRehype)\\n    .use(rehypePrism)\\n    .use(rehypeStringify)\\n    .process(content, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"err, file\"), \") \"), \"{\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (err) \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"console\"), \".error(err);\\n\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" htmlNodeData = {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"html\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file),\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"slug\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${node.relativePath.replace(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-regexp\"\n  }), \"/\\\\.[^/.]+$/\"), \", \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"''\"), \")}\"), \"`\"), \"\\n      };\\n\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" htmlNodeMetaData = {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"id\"), \": createNodeId(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`id-html-\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${node.absolutePath}\"), \"`\"), \"),\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"parent\"), \": node.id,\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"children\"), \": [],\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"internal\"), \": {\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"type\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'BlogHTML'\"), \",\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"mediaType\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'text/html'\"), \",\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"contentDigest\"), \": createContentDigest(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"String\"), \"(file))\\n        }\\n      };\\n\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" htmlNode = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"Object\"), \".assign({}, htmlNodeData, htmlNodeMetaData);\\n\\n      createNode(htmlNode);\\n      createParentChildLink({ \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"parent\"), \": node, \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"child\"), \": htmlNode });\\n    });\\n};\\n\")), mdx(\"p\", null, \"Unified allows us to hook into the processing stream of our markdown files. In the first step, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"remarkParse\"), \" parses our markdown file into what's known as an \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/Abstract_syntax_tree\"\n  }), \"abstract syntax tree (AST)\"), \". It essentially takes each component of the markdown file, header, paragraph, image, and creates an object out of each. For example, here is the syntax tree for our level-two.md:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), \"{\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"root\\\"\"), \",\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"children\\\"\"), \":[\\n     {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"heading\\\"\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"depth\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"1\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"children\\\"\"), \":[\\n           {\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"text\\\"\"), \",\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"value\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"Level Two\\\"\"), \",\\n           }\\n        ]\\n     },\\n     {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"paragraph\\\"\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"children\\\"\"), \":[\\n           {\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"text\\\"\"), \",\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"value\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"This is our second post, we're \\\"\"), \",\\n           },\\n           {\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"emphasis\\\"\"), \",\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"children\\\"\"), \":[\\n                 {\\n                    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"text\\\"\"), \",\\n                    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"value\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"really\\\"\"), \",\\n                 }\\n              ]\\n           },\\n           {\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"type\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"text\\\"\"), \",\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\"value\\\"\"), \":\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"\\\" on a roll now aren't we?\\\"\"), \",\\n           }\\n        ]\\n     }\\n  ]\\n}\\n\")), mdx(\"p\", null, \"What we're doing here is hooking in right after the markdown file is processed into an AST, plucking out elements of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"image\"), \", then replacing their \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"url\"), \" property from the source-relative path to where we know the file is in our public runtime environment. Then, the parsing process finishes as usual.\"), mdx(\"p\", null, \"Typically, such gymnastics shouldn't be necessary. They're only needed if we want to avoid using the static folder and have images within our markdown files. For the majority of other purposes, you'll either just use a graphql query to pull in desired images as we showed, or you'll just have URLs to images hosted elsewhere if you're not stashing them locally. That being said, I don't know about you, but I had a lot of fun learning about abstract syntax trees. \\uD83E\\uDD13\"), mdx(\"h2\", null, \"Resimplifying with Gatsby Plugins\"), mdx(\"p\", null, \"So, now that we've really gotten into the weeds and created an entire build pipeline using Gatsby's architecture from scratch, how about we simplify our lives? Gatsby actually has a plugin for everything we did above, so let's remove all of our handcrafted code and swap in the relevant plugins.\"), mdx(\"p\", null, \"Our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"exports.sourceNodes\"), \" function replicates \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-filesystem\"), \". Our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"exports.onCreateNode\"), \" function replicates \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-transformer-remark\"), \", which parses the markdown to HTML, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-remark-prismjs\"), \", which adds syntax highlighting to code blocks, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-remark-images\"), \", which processes images in markdown to be used in the production build. Let's start by installing everything we'll need. The default starter already comes with the filesystem plugin, a few image utilities (but not remark-images) and some SEO tools. Before we do that, let's also uninstall the packages we used to manually do some of this stuff, since many of Gatsby's plugins use the same packages as dependencies.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-bash\"\n  }), \"$ npm uninstall rehype-prism rehype-stringify remark remark-html remark-parse remark-rehype unified unist-util-visit\\n$ npm install gatsby-transformer-remark gatsby-remark-prismjs gatsby-remark-images prismjs\\n\")), mdx(\"p\", null, \"Now, let's configure our plugins.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-config.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"module\"), \".exports = {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"plugins\"), \": [\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n    {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"resolve\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby-source-filesystem'\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"options\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"name\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'markdown-pages-images'\"), \",\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-subst\"\n  }), \"${__dirname}\"), \"/content`\"), \"\\n      }\\n    },\\n    {\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"resolve\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby-transformer-remark'\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"options\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"plugins\"), \": [\\n          {\\n            \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"resolve\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby-remark-images'\"), \",\\n            \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"options\"), \": {\\n              \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"maxWidth\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-number\"\n  }), \"1000\"), \"\\n            }\\n          },\\n          \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby-remark-prismjs'\"), \"\\n        ]\\n      }\\n    }\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"//\\u2026\"), \"\\n  ]\\n};\\n\")), mdx(\"p\", null, \"We're adding a configuration for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-filesystem\"), \" with the directory of our content. We're also adding the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-transformer-remark\"), \" plugin, with a couple of child plugins, which are related to parsing markdown files, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-remark-images\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-remark-prismjs\"), \".\"), mdx(\"p\", null, \"Next, let's make the needed adjustments to our gatsby-node.js file. First, we can completely remove the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sourceNodes\"), \" function, since the plugins create all of our nodes for us. We also need to make a few tweaks to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createPages\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCreateNode\"), \" functions.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"gatsby-node.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-javascript\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createFilePath } = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby-source-filesystem'\"), \");\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".createPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({ graphql, actions }) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createPage } = actions;\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" markdownPages = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"await\"), \" graphql(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\\n    query {\\n      allMarkdownRemark {\\n        edges {\\n          node {\\n            fields {\\n              slug\\n            }\\n          }\\n        }\\n      }\\n    }\\n  `\"), \");\\n\\n  markdownPages.data.allMarkdownRemark.edges.forEach(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ node }\"), \") =\u003e\"), \" {\\n    createPage({\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"path\"), \": node.fields.slug,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"component\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"require\"), \".resolve(\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'./src/templates/blog-post.js'\"), \"),\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"context\"), \": {\\n        \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"slug\"), \": node.fields.slug\\n      }\\n    });\\n  });\\n};\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-built_in\"\n  }), \"exports\"), \".onCreateNode = \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"async\"), \" ({ node, getNode, actions }) =\u003e {\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" { createNodeField } = actions;\\n\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"if\"), \" (node.internal.type === \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'MarkdownRemark'\"), \") {\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" slug = createFilePath({ node, getNode });\\n    createNodeField({\\n      node,\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"name\"), \": \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'slug'\"), \",\\n      \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"value\"), \": slug\\n    });\\n  }\\n};\\n\")), mdx(\"p\", null, \"That's the whole file now! That really cleans things up doesn't it?! \\uD83D\\uDE0C One completely new item is that in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onCreateNode\"), \" we have to create our own slug for the MardownRemark nodes. We can actually specify these in the markdown post's \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gatsbyjs.org/docs/adding-markdown-pages/#frontmatter-for-metadata-in-markdown-files\"\n  }), \"frontmatter\"), \" if we wanted to, since MarkdownRemark gives us frontmatter parsing as a free bonus! However, if your file names are going to be consistent with your slugs, you can just create a slug field using the relative file path to make things a bit easier, and it's also simplified by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-filesystem\"), \" as it provides a function to do so.\"), mdx(\"p\", null, \"The last change we made was to change our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"allBlogHtml\"), \" node names in the query to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"allMarkdownRemark\"), \". It's important to note also that since we added the slug as a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"field\"), \", you need to access it with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node.fields.slug\"), \" rather than just \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node.slug\"), \". Finally, we just need to change the node names in our template file.\"), mdx(\"div\", {\n    \"className\": \"remark-code-title\"\n  }, \"src/templates/blog-post.js\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"hljs language-jsx\"\n  }), mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"import\"), \" { graphql } \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"from\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'gatsby'\"), \";\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"import\"), \" React \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"from\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"'react'\"), \";\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"default\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-function\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"function\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-title\"\n  }), \"BlogPost\"), \"(\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-params\"\n  }), \"{ data }\"), \") \"), \"{\\n  \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"return\"), \" (\\n    \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"xml\"\n  }), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"dangerouslySetInnerHTML\"), \"=\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"{{\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"__html:\"), \" \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-attr\"\n  }), \"data.markdownRemark.html\"), \" }}\u003e\"), mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-tag\"\n  }), \"\u003c/\", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"hljs-name\"\n  }), \"div\"), \"\u003e\")), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-comment\"\n  }), \"// highlight-line\"), \"\\n  );\\n}\\n\\n\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"export\"), \" \", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-keyword\"\n  }), \"const\"), \" query = graphql\", mdx(\"span\", _extends({\n    parentName: \"code\"\n  }, {\n    \"className\": \"hljs-string\"\n  }), \"`\\n  query($slug: String!) {\\n    markdownRemark(fields: { slug: { eq: $slug } }) { // highlight-line\\n      html\\n    }\\n  }\\n`\"), \";\\n\")), mdx(\"p\", null, \"Restart Gatsby and voila! Everything is exactly as it was before, with 95% less \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"custom\"), \" code. However, we'll be wise to note that all of the functionality we just removed from our own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" is now in each plugin's own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file.\"), mdx(\"p\", null, \"That's how Gatsby's plugin system works. Plugins provide their own functionality by wrapping everything in a tidy package which contains just the Gatsby APIs they utilize. If you \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-source-filesystem/src\"\n  }), \"open the code\"), \" for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-source-filesystem\"), \" for example, you'll see it also has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file which does what we coded ourselves (and much more, of course). When we install the plugin and add it to our configuration, the idea is it \\\"plugs in\\\" to our own project's Gatsby build process as though we had the code in our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file.\"), mdx(\"p\", null, \"Likewise, if we were to make our own plugin that we wanted to reuse in other projects, or even publish publicly, we could extract the relevant code from our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file into a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/plugins/my-plugin\"), \" folder with its own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby-node.js\"), \" file, and we'd pretty much be ready to use it. Neat!\"), mdx(\"p\", null, \"I created this post in order to learn Gatsby more deeply as I created this very blog! So, if you're interested in seeing the full code as it stands at the end of this post, you can visit the relevant branches in the Github repository. The final version using our custom code is available at the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/Daynil/quests-in-code/tree/final-plugin-free\"\n  }), \"final-plugin-free\"), \" branch, and the final version after we swapped everything for Gatsby plugins is available at \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/Daynil/quests-in-code/tree/gatsby-plugins\"\n  }), \"gatsby-plugins\"), \".\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"So what have we learned from today's adventure?\"), mdx(\"p\", null, \"We took a deep dive into Gatsby's internals, and essentially reimplemented basic functioning versions of some of Gatsby's popular plugins. Along the way, I think we've certainly developed an appreciation for the complexity that is abstracted away.\"), mdx(\"p\", null, \"However, since we didn\\u2019t shy away from this complexity initially, we now understand exactly how many of Gatsby's key core systems operate, and we're well equipped to understand exactly how most plugins operate, as well as how to create our own for custom use cases if needed.\"), mdx(\"p\", null, \"For me, tools like Gatsby really come alive when you don't just take their abstractions for granted, instead diving in head-first and really taking the time to figure out how things work and come together. Once you've developed a robust mental model for the foundational principles, as we have, you can take a step back and leverage the advantages of such a tool.\"), mdx(\"p\", null, \"Well, one might think, if after swapping out our code for Gatsby plugins we ended up with exactly the same thing, what exactly did we gain other than writing less custom code?\"), mdx(\"p\", null, \"As you may have noticed, our implementations of the plugin were very basic and na\\xEFve. We wouldn't want to use code like that in production. Many edge cases are not addressed, and we only built it to function exactly how we were currently trying to use it.\"), mdx(\"p\", null, \"Rather than having to build production-ready code for every single use case, we can utilize some of Gatsby's existing plugins to save us a ton of time and energy, and we get a lot of additional bonuses. You may have noticed, for example, that while it is loading, our cat image now holds its position in the page, and blurs in when we open our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"level-one\"), \" blog post. Super cool! These are clearly non-trivial things to accomplish, but we get a robust mechanism for doing them for free with our plugins.\"), mdx(\"p\", null, \"If we ever run into the limitations of existing plugins, or we need to source data from new places, we now know exactly where to start. In the same spirit as this blog post, if you ever feel you don't understand something about a plugin, or it seems not to work right for some reason, don't be shy about diving into the plugin's codebase. You know how it should work now!\"), mdx(\"p\", null, \"With that, it's onward to new adventures!\"));\n}\n\n;\nMDXContent.isMDXComponent = true;","renderedOutput":"\u003cp\u003eAre you the type of person that likes to poke around under the hood before getting started with something new? Me too!\u003c/p\u003e\u003cp\u003eIf you want to get started with Gatsby quickly, Gatsby has excellent \u003ca href=\"https://www.gatsbyjs.org/docs/\"\u003edocumentation\u003c/a\u003e. Have a look at their quick start, pick a nice starter template, create your app with the starter template, and you\u0026#x27;re off to the races!\u003c/p\u003e\u003cp\u003eHowever, I\u0026#x27;ve never been one that takes complexity for granted. To be sure, there is a reason for the complexity Gatsby introduces, but you truly need to understand it in order to appreciate what it brings to the table. Complexity is a trade-off, so you really need to consider why you would want to use something like Gatsby over, say, a simple site with just HTML and some CSS and javascript sprinkled in as needed.\u003c/p\u003e\u003ch2\u003ePlan to Learn Gatsby In Depth\u003c/h2\u003e\u003cp\u003eGatsby has a lot of moving pieces, particularly when you start adding plugins, and it\u0026#x27;s easy to get overwhelmed as you inevitably start customizing to suite your sites and preferences. Plugins are an extremely useful tool in Gatsby, and the community that has developed around it is \u003ca href=\"https://www.gatsbyjs.org/plugins/\"\u003equite rich\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eHowever, the best way to understand Gatsby is starting completely bare, with no plugins or starters, even those developed by the Gatsby team. Eventually, those tools will add much convenience and velocity to your development. But if you want to understand everything that\u0026#x27;s going on, its nice to start from scratch and work your way up.\u003c/p\u003e\u003cp\u003eClearly there are far too many plugins to break each one down and understand them all in one shot before you even start using Gatsby, and that would be counter to the purpose of Gatsby. But there are a few core features of Gatsby which, if you can dig into them deeply and understand them at the lowest level, you will have a solid foundation upon which to draw from in your work with Gatsby.\u003c/p\u003e\u003cp\u003eAfter our exploration of Gatsby today, we\u0026#x27;ll:\u003c/p\u003e\u003cul\u003e\u003cli\u003eUnderstand how Gatsby\u0026#x27;s build process works\u003c/li\u003e\u003cli\u003eUnderstand how most plugins work and how they hook into Gatsby\u003c/li\u003e\u003cli\u003eHave a clear vision for building our own plugins or extensions when we need them\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe three core features that most websites will be utilizing in Gatsby that we\u0026#x27;ll look to dig into are:\u003c/p\u003e\u003cul\u003e\u003cli\u003eSourcing external data for consumption in Gatsby\u003c/li\u003e\u003cli\u003ePassing data to components to programmatically create pages\u003c/li\u003e\u003cli\u003ePlugging into Gatsby\u0026#x27;s data management layer, GraphQL\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOnce we manually implement a basic functioning version of all of these, we\u0026#x27;ll have an appreciation for the simplicity that Gatsby\u0026#x27;s plugin architecture brings and we\u0026#x27;ll swap out our code for the plugins that do the same thing and take advantage of the many performance improvements Gatsby offers.\u003c/p\u003e\u003ch2\u003eWhat are we building?\u003c/h2\u003e\u003cp\u003eFor today\u0026#x27;s adventure, we\u0026#x27;ll be building…this very blog! A blog is among the most common use cases for a static site generator, so it\u0026#x27;s a great place to start learning about Gatsby. I chose Gatsby for this site (after some substantially extensive, yet characteristic, angst about whether to use a CMS like \u003ca href=\"https://wordpress.org/\"\u003eWordPress\u003c/a\u003e or any of a large number of \u003ca href=\"https://www.staticgen.com/\"\u003eother static site generators\u003c/a\u003e…) because I wanted to keep server costs to a minimum, as well as leverage my existing knowledge of javascript and React to add many bits of dynamism to the site that would typically be more challenging with a CMS or a static site generator that uses a different programming language.\u003c/p\u003e\u003cp\u003eGatsby\u0026#x27;s documentation has a great summary of \u003ca href=\"https://www.gatsbyjs.org/features/cms/\"\u003ewhy you would use it over a traditional CMS\u003c/a\u003e, or \u003ca href=\"https://www.gatsbyjs.org/features/jamstack/\"\u003eother static site generators\u003c/a\u003e.\u003c/p\u003e\u003cp\u003eIn the end, they all achieve very similar things in different ways, so the choice is personal. However, after some tinkering with various options, I\u0026#x27;ve found Gatsby to be the best for the most important reason: it\u0026#x27;s the most fun to use!\u003c/p\u003e\u003cp\u003eI\u0026#x27;ve played a bit with Gatsby in my experimentation, but I don\u0026#x27;t feel that I\u0026#x27;ve learned it enough to be satisfied with my foundational knowledge. So, this post will be an exploration of learning Gatsby in depth by building a thing from scratch!\u003c/p\u003e\u003cp\u003eThe final version using our custom code is available at the \u003ca href=\"https://github.com/Daynil/quests-in-code/tree/final-plugin-free\"\u003efinal-plugin-free\u003c/a\u003e branch in the Github repository for this blog, if you ever want to see the full picture of the code.\u003c/p\u003e\u003ch2\u003eStarting From Scratch\u003c/h2\u003e\u003cp\u003eTo get started, let\u0026#x27;s use the gatsby CLI to generate the default blank starter.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ npm install -g gatsby-cli\n$ gatsby new quests-in-code\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe Gatsby CLI allows you to pass an optional parameter called \u003ccode\u003estarter-url\u003c/code\u003e, which can provide many useful defaults such as plugins for parsing markdown, for using typescript, etc. However, for our learning purposes we want to start with the minimum available option. If you do not pass anything for the starter-url, the default blank starter used, \u003ccode\u003egatsby-starter-default\u003c/code\u003e. You can also pass \u003ccode\u003egatsby-starter-default\u003c/code\u003e as the parameter, but that does the same thing as omitting it. Once Gatsby finishes installing everything, you\u0026#x27;ll see a success message. Let\u0026#x27;s explore what Gatsby has scaffolded out for us.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ \u003cspan class=\"hljs-built_in\"\u003ecd\u003c/span\u003e quests-in-code\n$ code .\n$ gatsby develop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat we see is a very simple starter application with a few things already in place. We have 3 pages, a few components to be used within pages, and a couple of images.\u003c/p\u003e\u003cp\u003eIf you open up \u003ccode\u003egatsby-config.js\u003c/code\u003e, you\u0026#x27;ll notice there are actually already a number of plugins included even in this default blank starter:\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-config.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-attr\"\u003esiteMetadata\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`Gatsby Default Starter`\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`Kick off your next, great Gatsby project with this default starter. This barebones starter ships with the main Gatsby configuration files you might need.`\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eauthor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`@gatsbyjs`\u003c/span\u003e\n  },\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n    \u003cspan class=\"hljs-string\"\u003e`gatsby-plugin-react-helmet`\u003c/span\u003e,\n    {\n      \u003cspan class=\"hljs-attr\"\u003eresolve\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`gatsby-source-filesystem`\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`images`\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${__dirname}\u003c/span\u003e/src/images`\u003c/span\u003e\n      }\n    },\n    \u003cspan class=\"hljs-string\"\u003e`gatsby-transformer-sharp`\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e`gatsby-plugin-sharp`\u003c/span\u003e,\n    {\n      \u003cspan class=\"hljs-attr\"\u003eresolve\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`gatsby-plugin-manifest`\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`gatsby-starter-default`\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eshort_name\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`starter`\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003estart_url\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`/`\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ebackground_color\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`#663399`\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003etheme_color\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`#663399`\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003edisplay\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`minimal-ui`\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eicon\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`src/images/gatsby-icon.png`\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// This path is relative to the root of the site.\u003c/span\u003e\n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e// this (optional) plugin enables Progressive Web App + Offline functionality\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// To learn more, visit: https://gatsby.dev/offline\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// `gatsby-plugin-offline`,\u003c/span\u003e\n  ]\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe will be needing all of these eventually, but we will start building out our blog without them so we can understand what they are for.\u003c/p\u003e\u003cp\u003eFirst, let\u0026#x27;s create a simple page ourselves just to make sure we understand the very basics. Create a file called \u003ccode\u003eblog-post.js\u003c/code\u003e in the pages folder. Gatsby automatically builds a page with the URL as the file name for files in this folder. Throw an image called \u003ccode\u003ecat-1.jpg\u003c/code\u003e into the images folder so we can explore how to use our own images.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003esrc/pages/blog-post.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e React \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Cat1 \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../images/cat-1.jpg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBlogPost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003eLevel One\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eh1\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecolor:\u003c/span\u003e \u0026#x27;#\u003cspan class=\"hljs-attr\"\u003e718096\u003c/span\u003e\u0026#x27;, \u003cspan class=\"hljs-attr\"\u003efontSize:\u003c/span\u003e \u0026#x27;\u003cspan class=\"hljs-attr\"\u003e18px\u003c/span\u003e\u0026#x27; }}\u0026gt;\u003c/span\u003eMarch 8th, 2020\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e\n        This is the first post in the blog, currently just a placeholder but we\n        will soon add lots of \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ei\u003c/span\u003e\u0026gt;\u003c/span\u003eawesome\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ei\u003c/span\u003e\u0026gt;\u003c/span\u003e meaningful content.\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{Cat1}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;700px\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, navigate to http://localhost:8000/blog-post and you will see our first blog post show up as expected.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"./level-one-post.png\" alt=\"Blogpost built in React screenshot\"/\u003e\u003c/p\u003e\u003cp\u003eAwesome, that was easy enough right?!\u003c/p\u003e\u003cp\u003eOf course, as simple as Gatsby makes this, we don\u0026#x27;t want to have to take the time to write all of our blog posts in raw JSX. There are several ways to author content in a more user friendly way, then use Gatsby to create pages out of it. One of the most popular ways is using a content management system, such as \u003ca href=\"https://www.netlifycms.org/\"\u003eNetlify CMS\u003c/a\u003e. Another popular and simple way, which we will use, is markdown files.\u003c/p\u003e\u003ch2\u003eUsing Markdown\u003c/h2\u003e\u003cp\u003eLet\u0026#x27;s create a couple of super simple markdown placeholders for our first 2 posts. We\u0026#x27;ll create a folder called content in the base directory with two markdown files, them move our cat image here as well. Here\u0026#x27;s what we will have as of now:\u003c/p\u003e\u003cp\u003e\u003cimg src=\"./markdown-folder.png\" alt=\"Gatsby content folder structure screenshot\"/\u003e\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003econtent/level-one.md\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-markdown\"\u003e\u003cspan class=\"hljs-section\"\u003e# Level One\u003c/span\u003e\n\nThis is the first post in the blog, currently just a placeholder but we will soon add lots of \u003cspan class=\"hljs-emphasis\"\u003e_awesome_\u003c/span\u003e meaningful content.\n\n\u003cspan class=\"hljs-section\"\u003e### This came from a markdown file!\u003c/span\u003e\n\n![\u003cspan class=\"hljs-string\"\u003eFunny Cat\u003c/span\u003e](\u003cspan class=\"hljs-link\"\u003e/cat-1.jpg\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\u003cdiv class=\"remark-code-title\"\u003econtent/level-two.md\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-markdown\"\u003e\u003cspan class=\"hljs-section\"\u003e# Level Two\u003c/span\u003e\n\nThis is our second post, we\u0026#x27;re \u003cspan class=\"hljs-emphasis\"\u003e_really_\u003c/span\u003e on a roll now aren\u0026#x27;t we?\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGreat, we\u0026#x27;ve got some posts written! But now what, how do we see them in the browser?\u003c/p\u003e\u003cp\u003eThis is where our adventure really begins to get interesting!\u003c/p\u003e\u003cp\u003eRight now, Gatsby doesn\u0026#x27;t know anything about our markdown files. We need to tell Gatsby how to process and display these markdown files. Our current \u003ccode\u003eblog-post.js\u003c/code\u003e page file just displays some hard-coded strings and we\u0026#x27;re not creating any pages for the markdown files.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s start fix this by teaching Gatsby how to parse a markdown file into HTML so that we can use it in our site. First, let\u0026#x27;s install a markdown parser. There are several options, but we\u0026#x27;ll use \u003ca href=\"https://remark.js.org/\"\u003eremark\u003c/a\u003e since that\u0026#x27;s what Gatsby\u0026#x27;s main markdown plugin uses, which we will switch to once we understand what it is doing under the hood.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ npm install remark remark-html\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGatsby has a special file called \u003ccode\u003egatsby-node.js\u003c/code\u003e which is run once when your site is being built. We can use this file to parse the markdown files. Let\u0026#x27;s start by just parsing our first markdown post and logging it out to the console.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e remark = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;remark\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e html = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;remark-html\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;fs\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.createPages = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post1 = fs.readFileSync(\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./content/level-one.md\u0026#x27;\u003c/span\u003e));\n\n  remark()\n    .use(html)\n    .process(post1, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, file\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file));\n    });\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// Output:\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026lt;h1\u0026gt;Level One\u0026lt;/h1\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026lt;p\u0026gt;This is the first post in the blog, currently just a placeholder but we will soon add lots of \u0026lt;em\u0026gt;awesome\u0026lt;/em\u0026gt; meaningful content.\u0026lt;/p\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026lt;p\u0026gt;\u0026lt;img src=\u0026quot;/cat-1.jpg\u0026quot; alt=\u0026quot;Funny Cat\u0026quot;\u0026gt;\u0026lt;/p\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGreat! So now we\u0026#x27;ve read in our markdown file into memory with node\u0026#x27;s readFileSync API, then parsed it to HTML using remark. Now we need a way to display this parsed HTML with Gatsby.\u003c/p\u003e\u003ch2\u003eProgrammatic Page Generation\u003c/h2\u003e\u003cp\u003eIn Gatsby, you create page templates in order to programmatically generate pages. So, let\u0026#x27;s move our \u003ccode\u003eblog-post.js\u003c/code\u003e component to \u003ccode\u003esrc/templates\u003c/code\u003e (and remove the hard coded image if you moved it to the content folder earlier). Now that \u003ccode\u003eblog-post.js\u003c/code\u003e is in templates and not pages, Gatsby will no longer automatically generate a page for it. Gatsby expects us to explain how to create this page programmatically, so let\u0026#x27;s do that.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e remark = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;remark\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e html = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;remark-html\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;fs\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.createPages = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post1 = fs.readFileSync(\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./content/level-one.md\u0026#x27;\u003c/span\u003e));\n\n  remark()\n    .use(html)\n    .process(post1, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, file\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file));\n      createPage({\n        \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/blog-post\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/templates/blog-post.js\u0026#x27;\u003c/span\u003e)\n      });\n    });\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow restart the development server and go back to http://localhost:8000/blog-post and you\u0026#x27;ll see that it still works. Ok, what was the point of that? We\u0026#x27;ve just imperatively done what Gatsby did for us automatically by convention when this file was in the pages. Well, this is where the power of Gatsby comes in. Now that we can tap into Gatsby\u0026#x27;s build system, we can use whatever data we want and map it to page templates. We can make use of our parsed markdown file by passing it to our template using createPage\u0026#x27;s context property.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// …\u003c/span\u003e\nremark()\n  .use(html)\n  .process(post1, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, file\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file));\n    createPage({\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/blog-post\u0026#x27;\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/templates/blog-post.js\u0026#x27;\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003epost\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file)\n      }\n    });\n  });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow our blog-post template component has access to the context via the pageContext prop, so let\u0026#x27;s replace the hard-coded post in blog-post.js with dynamically set HTML from the markdown.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003esrc/templates/blog-post.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e React \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBlogPost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ pageContext }\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edangerouslySetInnerHTML\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e__html:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epageContext.post\u003c/span\u003e }}\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRestart your development server and go back to our blog post URL. It works! However, there is one small issue - the image doesn\u0026#x27;t load, what gives?! The path is set correctly, but Gatsby doesn\u0026#x27;t know where to look for the image, since we have only told Gatsby how to process markdown files, not images.\u003c/p\u003e\u003cp\u003eWhen you pass a relative path, by default Gatsby looks for images at the root static folder: \u003ccode\u003estatic/\u003c/code\u003e. If we move our \u003ccode\u003ecat-1.jpg\u003c/code\u003e from \u003ccode\u003econtent/cat-1.jpg\u003c/code\u003e to \u003ccode\u003estatic/cat-1.jpg\u003c/code\u003e and refresh the development server, the image will show up as expected. This isn\u0026#x27;t ideal, since we\u0026#x27;re creating a conceptual gap between where a file\u0026#x27;s relative path is in your development environment\u0026#x27;s folder structure versus where it ends up in Gatsby\u0026#x27;s runtime environment.\u003c/p\u003e\u003cp\u003eGatsby\u0026#x27;s plugins solve this by registering the relative paths and mapping them to the static folder in the output directory. For example, you\u0026#x27;ll see with one of the default images from the starter, in the source directory, it lives under \u003ccode\u003esrc/images/gatsby-astronaut.png\u003c/code\u003e, but upon running \u003ccode\u003e$ gatsby build\u003c/code\u003e, the image gets moved to \u003ccode\u003epublic/static/{generatedId}/{generatedId}/gatsby-astronaut.png\u003c/code\u003e. Gatsby\u0026#x27;s plugin also generates different image sizes for each image, which is what the various subfolders for each image contain.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"./astronaut-src.png\" alt=\"Gatsby source image folder structure\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"./astronaut-build.png\" alt=\"Gatsby public static build folder structure\"/\u003e\u003c/p\u003e\u003cp\u003eWe\u0026#x27;ll also note that once we put our \u003ccode\u003ecat-1.jpg\u003c/code\u003e into the static folder, during the build Gatsby puts it in the root directory, not the static directory, so we can access it directly using what appears to be a relative path: \u003ccode\u003e/cat-1.jpg\u003c/code\u003e.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"./cat-build.png\" alt=\"Gatsby source static build folder structure\"/\u003e\u003c/p\u003e\u003cp\u003eEssentially, we haven\u0026#x27;t told Gatsby anything about how to process images, but its build process just moves files in the static directory as-is to the root public directory. We can allow the use of more logical relative paths imperatively by hooking into Gatsby\u0026#x27;s build system and moving the files into the static folder at build time or moving it to the appropriate folder in the built directory. However, let\u0026#x27;s just leave it in the static folder for now so we can focus on the markdown files first.\u003c/p\u003e\u003cp\u003eOur blog-post template is now fully dynamic and is the only thing we need to render all of our markdown files. Let\u0026#x27;s prove this out by creating another page for our other post. The only thing we need to change is the path, creating a unique slug for each post.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e// …\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.createPages = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ actions }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createPage } = actions;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contentDir = fs.readdirSync(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./content/\u0026#x27;\u003c/span\u003e);\n\n  contentDir.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003emdFilePath\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post = fs.readFileSync(\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e`./content/\u003cspan class=\"hljs-subst\"\u003e${mdFilePath}\u003c/span\u003e`\u003c/span\u003e));\n\n    remark()\n      .use(html)\n      .process(post, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, file\u003c/span\u003e) \u003c/span\u003e{\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n        \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file));\n        createPage({\n          \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`/\u003cspan class=\"hljs-subst\"\u003e${mdFilePath.replace(\u003cspan class=\"hljs-regexp\"\u003e/\\.[^/.]+$/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e)}\u003c/span\u003e`\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/templates/blog-post.js\u0026#x27;\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: {\n            \u003cspan class=\"hljs-attr\"\u003epost\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file)\n          }\n        });\n      });\n  });\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow refresh the development server, and both of our posts will be available at the URLs corresponding to their markdown file name: http://localhost:8000/level-one and http://localhost:8000/level-two. Neat!\u003c/p\u003e\u003ch2\u003eCode Block Syntax Highlighting\u003c/h2\u003e\u003cp\u003eNow, given that we\u0026#x27;re coders, we\u0026#x27;re obviously going to want to be able to utilize syntax highlighted code in our blog to show off our cool code snippets right? Of course, silly question. So let\u0026#x27;s add a markdown file with some code and see how it looks with our current setup.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003econtent/level-three.md\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-markdown\"\u003e\u003cspan class=\"hljs-section\"\u003e# Level Three\u003c/span\u003e\n\nThis is a really informative post with a really fancy code snippet.\n\n\u003cspan class=\"hljs-code\"\u003e```javascript\nconst pluckDeep = key =\u0026gt; obj =\u0026gt;\n  key.split(\u0026#x27;.\u0026#x27;).reduce((accum, key) =\u0026gt; accum[key], obj);\n\nconst compose = (...fns) =\u0026gt; res =\u0026gt;\n  fns.reduce((accum, next) =\u0026gt; next(accum), res);\n\nconst unfold = (f, seed) =\u0026gt; {\n  const go = (f, seed, acc) =\u0026gt; {\n    const res = f(seed);\n    return res ? go(f, res[1], acc.concat([res[0]])) : acc;\n  };\n  return go(f, seed, []);\n};\n```\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNavigate to our new /level-three page URL in the browser and you\u0026#x27;ll see that we have a nice code block with our code, but no syntax highlighting. That may work fine for Medium (😏) but we\u0026#x27;re much cooler than that, so let\u0026#x27;s add it! First, we need to install a syntax highlighter. However, we also need to install a few additional packages as well to help us with this new parsing task. Syntax highlighting code in markdown is more complex than just turning it straight into HTML since we now have to tokenize individual characters and highlight them appropriately depending on the language. To achieve this, we can use \u003ca href=\"https://prismjs.com/\"\u003ePrismJS\u003c/a\u003e and a few helpers.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ npm install prismjs unified remark-parse remark-rehype rehype-prism rehype-stringify\n\u003c/code\u003e\u003c/pre\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e unified = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;unified\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e remarkParse = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;remark-parse\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e remarkRehype = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;remark-rehype\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rehypePrism = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;rehype-prism\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e rehypeStringify = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;rehype-stringify\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;fs\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.createPages = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ actions }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createPage } = actions;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contentDir = fs.readdirSync(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./content/\u0026#x27;\u003c/span\u003e);\n\n  contentDir.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003emdFilePath\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e post = fs.readFileSync(\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e`./content/\u003cspan class=\"hljs-subst\"\u003e${mdFilePath}\u003c/span\u003e`\u003c/span\u003e));\n\n    unified()\n      .use(remarkParse)\n      .use(remarkRehype)\n      .use(rehypePrism)\n      .use(rehypeStringify)\n      .process(post, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, file\u003c/span\u003e) \u003c/span\u003e{\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n        \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file));\n        createPage({\n          \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`/\u003cspan class=\"hljs-subst\"\u003e${mdFilePath.replace(\u003cspan class=\"hljs-regexp\"\u003e/\\.[^/.]+$/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e)}\u003c/span\u003e`\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/templates/blog-post.js\u0026#x27;\u003c/span\u003e),\n          \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: {\n            \u003cspan class=\"hljs-attr\"\u003epost\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file)\n          }\n        });\n      });\n  });\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we\u0026#x27;re parsing our markdown into tokens, using prism to apply the appropriate classes to each token, then turning it into HTML. However, if you refresh now, you\u0026#x27;ll see the syntax is still not highlighted. We\u0026#x27;ve inserted span elements with the correct classes to highlight each token of code, but we don\u0026#x27;t have any CSS classes set up yet. Let\u0026#x27;s take one of Prism\u0026#x27;s default themes, tomorrow night, and use that. You can insert styles globally in \u003ccode\u003egatsby-browser.js\u003c/code\u003e.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-browser.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;prismjs/themes/prism-tomorrow.css\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRestart Gatsby and you\u0026#x27;ll see the syntax is now highlighted!\u003c/p\u003e\u003ch2\u003eBringing it together with GraphQL\u003c/h2\u003e\u003cp\u003eWe\u0026#x27;ve now got the skeleton of a fully functioning technical blog. However, as we\u0026#x27;ve seen with our problem with relative image paths, handling the data can get a bit hairy. Gatsby helps simplify and streamline this process by allowing each data source to register its contents in its GraphQL layer. Once registered, you can issue concise GraphQL queries to get just the data you need for each page, using the same syntax regardless of the source of the data.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s start by loading our markdown file information into GraphQL.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { slash } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby-core-utils\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.sourceNodes = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ actions, createNodeId, createContentDigest }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createNode } = actions;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contentDir = fs.readdirSync(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./content/\u0026#x27;\u003c/span\u003e);\n\n  contentDir.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003emdFilePath\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nodeData = {\n      \u003cspan class=\"hljs-attr\"\u003eabsolutePath\u003c/span\u003e: slash(\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e`./content/\u003cspan class=\"hljs-subst\"\u003e${mdFilePath}\u003c/span\u003e`\u003c/span\u003e)),\n      \u003cspan class=\"hljs-attr\"\u003erelativePath\u003c/span\u003e: mdFilePath\n    };\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nodeMetaData = {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: createNodeId(\u003cspan class=\"hljs-string\"\u003e`id-\u003cspan class=\"hljs-subst\"\u003e${mdFilePath}\u003c/span\u003e`\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [],\n      \u003cspan class=\"hljs-attr\"\u003einternal\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;BlogMDFile\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emediaType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;text/markdown\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003econtentDigest\u003c/span\u003e: createContentDigest(nodeData)\n      }\n    };\n\n    createNode(\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.assign({}, nodeData, nodeMetaData));\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eInstead of just looping through each file, reading it, and parsing it all in one step, we\u0026#x27;re breaking it up into two pieces. Gatsby has the concept of \u0026quot;source\u0026quot; plugins, which load in data from a given source, and a \u0026quot;transformer\u0026quot; plugin, which converts data from one format to another. This level of modularity allows you to grab data from novel \u0026quot;sources\u0026quot; while still leveraging existing transformer plugs.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s say you have your markdown files hosted on some remote server for which there isn\u0026#x27;t a plugin yet. You can create a source, like we did above, to load the content in. Because you specified it was of type \u003ccode\u003etext/markdown\u003c/code\u003e in the \u003ccode\u003einternal.mediaType\u003c/code\u003e metadata, any available markdown transformer plugin can subsequently parse your data for this source, without knowing anything about how to get data from your novel source!\u003c/p\u003e\u003cp\u003eSo we\u0026#x27;ve just built the \u0026quot;source\u0026quot; portion. In the case of local filesystem sources, we don\u0026#x27;t actually need to load the raw data in unless we\u0026#x27;ll be using it. Our raw data is markdown, which we\u0026#x27;ll need to parse to HTML before we use it, so our source is just a pointer to the file in the form of its absolute path. If you were actually creating a plugin, Gatsby provides two options to handle loading in data from source.\u003c/p\u003e\u003cp\u003eThe simplest option, which most sources will use, is to just load your data into the node object itself. So if you had a nice bit of structured of JSON from your source, you would just add it to the \u003ccode\u003enodeData\u003c/code\u003e object, similar to what we did above. If you had content that is very large and could be lazy loaded, you could define a \u003ccode\u003eloadNodeContent\u003c/code\u003e function for the node, which consumers can use to load the data in only when it\u0026#x27;s requested.\u003c/p\u003e\u003cp\u003eThis is exactly what gatsby-source-filesystem does. In the \u003ccode\u003enodeData\u003c/code\u003e object, it just points to the file path as we have, and provides additional metadata, such as extension, size, etc. Then, it defines a the \u003ccode\u003eloadNodeContent\u003c/code\u003e function to specify how to read the data for consumers, which for a file on the local system could just be \u003ccode\u003efs.readFile(node.absolutePath)\u003c/code\u003e. We\u0026#x27;ll do something very similar.\u003c/p\u003e\u003cp\u003eGatsby\u0026#x27;s development server exposes an extremely useful interactive in-browser GraphQL IDE (integrated development environment) called GraphiQL, which shows you all of the data loaded into it. Let\u0026#x27;s open it and find our newly created nodes. By convention, they are under the name of the \u003ccode\u003einternal.type\u003c/code\u003e that you assigned to the node when you made it, in our case \u0026quot;BlogMDFile\u0026quot;. We actually have two versions here, \u0026quot;allBlogMdFile\u0026quot; and \u0026quot;blogMdFile\u0026quot;. They expose the same information, but as expected, the all version just shows all the nodes of the type while the other allows you to filter for individual ones.\u003c/p\u003e\u003cp\u003e\u003cimg src=\"./graphiql.png\" alt=\"Gatsby GraphiQL in-browser query exploration tool\"/\u003e\u003c/p\u003e\u003cp\u003eGreat! Now that we\u0026#x27;ve got our markdown files \u0026quot;sourced\u0026quot; into the GraphQL layer, we\u0026#x27;re going to use the information from these newly created nodes and create the \u0026quot;transformer\u0026quot; portion of our plugin, which will take the files and parse them, then load them into GraphQL as well.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.onCreateNode = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({\n  node,\n  actions,\n  createNodeId,\n  createContentDigest\n}) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createNode, createParentChildLink } = actions;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node.internal.mediaType !== \u003cspan class=\"hljs-string\"\u003e\u0026#x27;text/markdown\u0026#x27;\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e content = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e fs.readFileSync(node.absolutePath);\n  unified()\n    .use(remarkParse)\n    .use(remarkRehype)\n    .use(rehypePrism)\n    .use(rehypeStringify)\n    .process(content, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, file\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n      \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file));\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlNodeData = {\n        \u003cspan class=\"hljs-attr\"\u003ehtml\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file),\n        \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`/\u003cspan class=\"hljs-subst\"\u003e${node.relativePath.replace(\u003cspan class=\"hljs-regexp\"\u003e/\\.[^/.]+$/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e)}\u003c/span\u003e`\u003c/span\u003e\n      };\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlNodeMetaData = {\n        \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: createNodeId(\u003cspan class=\"hljs-string\"\u003e`id-html-\u003cspan class=\"hljs-subst\"\u003e${node.absolutePath}\u003c/span\u003e`\u003c/span\u003e),\n        \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: node.id,\n        \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [],\n        \u003cspan class=\"hljs-attr\"\u003einternal\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;BlogHTML\u0026#x27;\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003emediaType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;text/html\u0026#x27;\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003econtentDigest\u003c/span\u003e: createContentDigest(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file))\n        }\n      };\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlNode = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.assign({}, htmlNodeData, htmlNodeMetaData);\n\n      createNode(htmlNode);\n      createParentChildLink({ \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: node, \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: htmlNode });\n    });\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere we\u0026#x27;re just hooking into Gatsby\u0026#x27;s build process, looking for when nodes of type \u003ccode\u003etext/markdown\u003c/code\u003e are created, then using our existing code to parse that node\u0026#x27;s data to HTML and create a new node with it. There\u0026#x27;s no real difference here versus what we did back when we first created the code that parses our markdown, we\u0026#x27;ve just split it up and loaded it into GraphQL.\u003c/p\u003e\u003cp\u003eGreat, so now we\u0026#x27;ve got our parsed HTML again, but now it\u0026#x27;s loaded into the GraphQL layer. Now we can query that data the same way we would query anything in Gatsby. Let\u0026#x27;s rewrite our \u003ccode\u003ecreatePages\u003c/code\u003e function to leverage GraphQL.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.createPages = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ graphql, actions }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createPage } = actions;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e markdownPages = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e graphql(\u003cspan class=\"hljs-string\"\u003e`\n    query {\n      allBlogHtml {\n        edges {\n          node {\n            slug\n          }\n        }\n      }\n    }\n  `\u003c/span\u003e);\n\n  markdownPages.data.allBlogHtml.edges.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ node }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    createPage({\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: node.slug,\n      \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/templates/blog-post.js\u0026#x27;\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e: node.slug\n      }\n    });\n  });\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAwesome, that dramatically simplifies our \u003ccode\u003ecreatePages\u003c/code\u003e function. Now we\u0026#x27;re just querying grabbing the slug for each post and create a page for it. However, you\u0026#x27;ll note we\u0026#x27;re no longer passing the parsed HTML in the context. Well, how will our template know what to render?! Well, that\u0026#x27;s the beauty of GraphQL. We can now colocate the query for the data the template needs with the template itself! The only thing we need when we\u0026#x27;re actually creating the pages is the slug.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003esrc/templates/blog-past.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { graphql } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e React \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBlogPost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ data }\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edangerouslySetInnerHTML\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e__html:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata.blogHtml.html\u003c/span\u003e }}\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e query = graphql\u003cspan class=\"hljs-string\"\u003e`\n  query($slug: String!) {\n    blogHtml(slug: { eq: $slug }) {\n      html\n    }\n  }\n`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe\u0026#x27;ve passed the slug in as context, and when a page is created for a template, you can use keys from the context object to match up with arguments in the GraphQL page query. Variables in GraphQL are prefaced with \u003ccode\u003e$\u003c/code\u003e, so here passing a \u003ccode\u003eslug\u003c/code\u003e property into the context will pass \u003ccode\u003e$slug\u003c/code\u003e into the query, and we\u0026#x27;ve just specified it is of type string. The results of the query are now available in the props of the component under the aptly named \u003ccode\u003edata\u003c/code\u003e property by convention. \u003ccode\u003epageContext\u003c/code\u003e is also still available as a separate object in the component\u0026#x27;s props if it is needed (e.g. \u003ccode\u003eBlogPost({ data, context })\u003c/code\u003e), but in our case, the slug was only needed for the query.\u003c/p\u003e\u003cp\u003eRestart Gatsby and you\u0026#x27;ll see that our pages are once again available as they were, success!!\u003c/p\u003e\u003ch2\u003eDealing with Images\u003c/h2\u003e\u003cp\u003eOne last thing that we need to do is actually move our sourced files from our source directory to somewhere we can access them in the public build directory. This isn\u0026#x27;t strictly necessary for the markdown files, since we\u0026#x27;ve already parsed all the information out of them into a string on the \u003ccode\u003eblogHtml.html\u003c/code\u003e graphql node. However, remember our problem with the images? Here\u0026#x27;s where we fix that problem!\u003c/p\u003e\u003cp\u003eRecall that we temporarily dealt with the issue of our cat image not being available in the public directory by just moving it to Gatsby\u0026#x27;s \u003ccode\u003esrc/static\u003c/code\u003e folder. From there, Gatsby just dumps all the files into the root \u003ccode\u003epublic\u003c/code\u003e folder at build time, where we can use them in the runtime environment. The issue we had was the logical disconnect between where files are in the development \u003ccode\u003esrc\u003c/code\u003e directory versus where they end up in the \u003ccode\u003epublic\u003c/code\u003e directory at runtime.\u003c/p\u003e\u003cp\u003eLet\u0026#x27;s deal with this in a way that lets us organize our files logically. We\u0026#x27;ll move the \u003ccode\u003ecat-1.jpg\u003c/code\u003e back to the content folder, alongside our markdown posts, as we originally had it. Also, we\u0026#x27;ll go into our \u003ccode\u003elevel-one.md\u003c/code\u003e and make a slight adjustment to the image url to make it relative again, changing \u003ccode\u003e![Funny Cat](/cat-1.jpg)\u003c/code\u003e to \u003ccode\u003e![Funny Cat](./cat-1.jpg)\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNext, we need to do a few new things in our \u003ccode\u003esourceNodes\u003c/code\u003e function. First, create a \u003ccode\u003epublicURL\u003c/code\u003e field in node data which will tell us where each file we process will sit in the public directory. We\u0026#x27;ll put all of our files into the \u003ccode\u003epublic/static\u003c/code\u003e directory. Now that we\u0026#x27;re processing images in addition to markdown files, we\u0026#x27;ll need to set our \u003ccode\u003einternal.mediaType\u003c/code\u003e to correctly reflect the file type, otherwise our transformer will have a cow trying to parse an jpeg file into HTML. Then, we\u0026#x27;ll copy each file to its public location, so it will be accessible to our blog posts at runtime.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e path = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;path\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.sourceNodes = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ actions, createNodeId, createContentDigest }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createNode } = actions;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e contentDir = fs.readdirSync(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./content/\u0026#x27;\u003c/span\u003e);\n\n  contentDir.forEach(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003emdFilePath\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nodeData = {\n      \u003cspan class=\"hljs-attr\"\u003eabsolutePath\u003c/span\u003e: slash(\u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e`./content/\u003cspan class=\"hljs-subst\"\u003e${mdFilePath}\u003c/span\u003e`\u003c/span\u003e)),\n      \u003cspan class=\"hljs-attr\"\u003erelativePath\u003c/span\u003e: mdFilePath,\n      \u003cspan class=\"hljs-attr\"\u003epublicURL\u003c/span\u003e: slash(\n        path.resolve(process.cwd(), \u003cspan class=\"hljs-string\"\u003e\u0026#x27;public\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;static\u0026#x27;\u003c/span\u003e, mdFilePath)\n      ),\n      \u003cspan class=\"hljs-attr\"\u003epublicRelativePath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`/static/\u003cspan class=\"hljs-subst\"\u003e${mdFilePath}\u003c/span\u003e`\u003c/span\u003e\n    };\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e extension = mdFilePath.split(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;.\u0026#x27;\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e nodeMetaData = {\n      \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: createNodeId(\u003cspan class=\"hljs-string\"\u003e`id-\u003cspan class=\"hljs-subst\"\u003e${mdFilePath}\u003c/span\u003e`\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [],\n      \u003cspan class=\"hljs-attr\"\u003einternal\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;BlogMDFile\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003emediaType\u003c/span\u003e: extension === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;md\u0026#x27;\u003c/span\u003e ? \u003cspan class=\"hljs-string\"\u003e\u0026#x27;text/markdown\u0026#x27;\u003c/span\u003e : \u003cspan class=\"hljs-string\"\u003e\u0026#x27;image/jpeg\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003econtentDigest\u003c/span\u003e: createContentDigest(nodeData)\n      }\n    };\n\n    fs.copyFileSync(nodeData.absolutePath, nodeData.publicURL);\n\n    createNode(\u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.assign({}, nodeData, nodeMetaData));\n  });\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, we can access our images in runtime. If we wanted to use our cat image directly in our JSX, we could write a static or page query to grab the url. For example, we can create the following query in our blog post template to pull in the public URL:\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003esrc/templates/blog-post.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBlogPost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ data }\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{data.blogMdFile.publicRelativePath}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n      \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edangerouslySetInnerHTML\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e__html:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata.blogHtml.html\u003c/span\u003e }}\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e;\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e query = graphql\u003cspan class=\"hljs-string\"\u003e`\n  query($slug: String!) {\n    blogHtml(slug: { eq: $slug }) {\n      html\n    }\n    blogMdFile(relativePath: { eq: \u0026quot;cat-1.jpg\u0026quot; }) {\n      publicRelativePath\n    }\n  }\n`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn our case, the relative path is the same as the file name since the image is sitting in the same folder as the rest of our content, so we can just search by the file name. We grab the public relative path we created in our node for our files, and since we moved the image during the build to the static directory, we can now reference the files.\u003c/p\u003e\u003cp\u003eHowever, the astute reader will note that we\u0026#x27;ve clearly not solved the problem we set out to yet. In our markdown file, we referenced the image as relative to the source environment markdown file\u0026#x27;s location \u003ccode\u003e./cat-1.jpg\u003c/code\u003e. But we moved the files to a static folder, so it still won\u0026#x27;t resolve properly in the runtime environment. Since our file is written in markdown, we can\u0026#x27;t do any fancy graphql querying to retrieve files, nor would we want to. We just want to type a relative string with the file name in our blog post markdown and have it resolve properly. What do??\u003c/p\u003e\u003cp\u003eThis piece is just a bit trickier, but still worth exploring to make sure we\u0026#x27;ve fully wrapped our heads around everything going on under the hood. The complexity is that the markdown file to which the image is relative no longer exists as far as the runtime environment is concerned - it\u0026#x27;s parsed into an HTML fragment, which we insert into our template. So our only remaining choice is to fake it, hot-swapping the original relative URL with the public directory we know the file is in.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e visit = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;unist-util-visit\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.onCreateNode = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({\n  node,\n  actions,\n  createNodeId,\n  createContentDigest\n}) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createNode, createParentChildLink } = actions;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node.internal.mediaType !== \u003cspan class=\"hljs-string\"\u003e\u0026#x27;text/markdown\u0026#x27;\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e content = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e fs.readFileSync(node.absolutePath);\n  unified()\n    .use(remarkParse)\n    .use(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etransformer\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etree, file\u003c/span\u003e) \u003c/span\u003e{\n        visit(tree, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;image\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enode\u003c/span\u003e) \u003c/span\u003e{\n          \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e imageName = node.url.split(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./\u0026#x27;\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e];\n          node.url = \u003cspan class=\"hljs-string\"\u003e`/static/\u003cspan class=\"hljs-subst\"\u003e${imageName}\u003c/span\u003e`\u003c/span\u003e;\n        });\n      };\n    })\n    .use(remarkRehype)\n    .use(rehypePrism)\n    .use(rehypeStringify)\n    .process(content, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eerr, file\u003c/span\u003e) \u003c/span\u003e{\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (err) \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.error(err);\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlNodeData = {\n        \u003cspan class=\"hljs-attr\"\u003ehtml\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file),\n        \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`/\u003cspan class=\"hljs-subst\"\u003e${node.relativePath.replace(\u003cspan class=\"hljs-regexp\"\u003e/\\.[^/.]+$/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e)}\u003c/span\u003e`\u003c/span\u003e\n      };\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlNodeMetaData = {\n        \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: createNodeId(\u003cspan class=\"hljs-string\"\u003e`id-html-\u003cspan class=\"hljs-subst\"\u003e${node.absolutePath}\u003c/span\u003e`\u003c/span\u003e),\n        \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: node.id,\n        \u003cspan class=\"hljs-attr\"\u003echildren\u003c/span\u003e: [],\n        \u003cspan class=\"hljs-attr\"\u003einternal\u003c/span\u003e: {\n          \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;BlogHTML\u0026#x27;\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003emediaType\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;text/html\u0026#x27;\u003c/span\u003e,\n          \u003cspan class=\"hljs-attr\"\u003econtentDigest\u003c/span\u003e: createContentDigest(\u003cspan class=\"hljs-built_in\"\u003eString\u003c/span\u003e(file))\n        }\n      };\n\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e htmlNode = \u003cspan class=\"hljs-built_in\"\u003eObject\u003c/span\u003e.assign({}, htmlNodeData, htmlNodeMetaData);\n\n      createNode(htmlNode);\n      createParentChildLink({ \u003cspan class=\"hljs-attr\"\u003eparent\u003c/span\u003e: node, \u003cspan class=\"hljs-attr\"\u003echild\u003c/span\u003e: htmlNode });\n    });\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eUnified allows us to hook into the processing stream of our markdown files. In the first step, \u003ccode\u003eremarkParse\u003c/code\u003e parses our markdown file into what\u0026#x27;s known as an \u003ca href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\"\u003eabstract syntax tree (AST)\u003c/a\u003e. It essentially takes each component of the markdown file, header, paragraph, image, and creates an object out of each. For example, here is the syntax tree for our level-two.md:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e{\n  \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;root\u0026quot;\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e:[\n     {\n        \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;heading\u0026quot;\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\u0026quot;depth\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e:[\n           {\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e,\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;value\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;Level Two\u0026quot;\u003c/span\u003e,\n           }\n        ]\n     },\n     {\n        \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;paragraph\u0026quot;\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e:[\n           {\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e,\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;value\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;This is our second post, we\u0026#x27;re \u0026quot;\u003c/span\u003e,\n           },\n           {\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;emphasis\u0026quot;\u003c/span\u003e,\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;children\u0026quot;\u003c/span\u003e:[\n                 {\n                    \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e,\n                    \u003cspan class=\"hljs-string\"\u003e\u0026quot;value\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;really\u0026quot;\u003c/span\u003e,\n                 }\n              ]\n           },\n           {\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;type\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e,\n              \u003cspan class=\"hljs-string\"\u003e\u0026quot;value\u0026quot;\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e\u0026quot; on a roll now aren\u0026#x27;t we?\u0026quot;\u003c/span\u003e,\n           }\n        ]\n     }\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhat we\u0026#x27;re doing here is hooking in right after the markdown file is processed into an AST, plucking out elements of type \u003ccode\u003eimage\u003c/code\u003e, then replacing their \u003ccode\u003eurl\u003c/code\u003e property from the source-relative path to where we know the file is in our public runtime environment. Then, the parsing process finishes as usual.\u003c/p\u003e\u003cp\u003eTypically, such gymnastics shouldn\u0026#x27;t be necessary. They\u0026#x27;re only needed if we want to avoid using the static folder and have images within our markdown files. For the majority of other purposes, you\u0026#x27;ll either just use a graphql query to pull in desired images as we showed, or you\u0026#x27;ll just have URLs to images hosted elsewhere if you\u0026#x27;re not stashing them locally. That being said, I don\u0026#x27;t know about you, but I had a lot of fun learning about abstract syntax trees. 🤓\u003c/p\u003e\u003ch2\u003eResimplifying with Gatsby Plugins\u003c/h2\u003e\u003cp\u003eSo, now that we\u0026#x27;ve really gotten into the weeds and created an entire build pipeline using Gatsby\u0026#x27;s architecture from scratch, how about we simplify our lives? Gatsby actually has a plugin for everything we did above, so let\u0026#x27;s remove all of our handcrafted code and swap in the relevant plugins.\u003c/p\u003e\u003cp\u003eOur \u003ccode\u003eexports.sourceNodes\u003c/code\u003e function replicates \u003ccode\u003egatsby-source-filesystem\u003c/code\u003e. Our \u003ccode\u003eexports.onCreateNode\u003c/code\u003e function replicates \u003ccode\u003egatsby-transformer-remark\u003c/code\u003e, which parses the markdown to HTML, \u003ccode\u003egatsby-remark-prismjs\u003c/code\u003e, which adds syntax highlighting to code blocks, and \u003ccode\u003egatsby-remark-images\u003c/code\u003e, which processes images in markdown to be used in the production build. Let\u0026#x27;s start by installing everything we\u0026#x27;ll need. The default starter already comes with the filesystem plugin, a few image utilities (but not remark-images) and some SEO tools. Before we do that, let\u0026#x27;s also uninstall the packages we used to manually do some of this stuff, since many of Gatsby\u0026#x27;s plugins use the same packages as dependencies.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e$ npm uninstall rehype-prism rehype-stringify remark remark-html remark-parse remark-rehype unified unist-util-visit\n$ npm install gatsby-transformer-remark gatsby-remark-prismjs gatsby-remark-images prismjs\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow, let\u0026#x27;s configure our plugins.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-config.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  \u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n    \u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n    {\n      \u003cspan class=\"hljs-attr\"\u003eresolve\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby-source-filesystem\u0026#x27;\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;markdown-pages-images\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e`\u003cspan class=\"hljs-subst\"\u003e${__dirname}\u003c/span\u003e/content`\u003c/span\u003e\n      }\n    },\n    {\n      \u003cspan class=\"hljs-attr\"\u003eresolve\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby-transformer-remark\u0026#x27;\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n          {\n            \u003cspan class=\"hljs-attr\"\u003eresolve\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby-remark-images\u0026#x27;\u003c/span\u003e,\n            \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: {\n              \u003cspan class=\"hljs-attr\"\u003emaxWidth\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e\n            }\n          },\n          \u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby-remark-prismjs\u0026#x27;\u003c/span\u003e\n        ]\n      }\n    }\n    \u003cspan class=\"hljs-comment\"\u003e//…\u003c/span\u003e\n  ]\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe\u0026#x27;re adding a configuration for \u003ccode\u003egatsby-source-filesystem\u003c/code\u003e with the directory of our content. We\u0026#x27;re also adding the \u003ccode\u003egatsby-transformer-remark\u003c/code\u003e plugin, with a couple of child plugins, which are related to parsing markdown files, \u003ccode\u003egatsby-remark-images\u003c/code\u003e and \u003ccode\u003egatsby-remark-prismjs\u003c/code\u003e.\u003c/p\u003e\u003cp\u003eNext, let\u0026#x27;s make the needed adjustments to our gatsby-node.js file. First, we can completely remove the \u003ccode\u003esourceNodes\u003c/code\u003e function, since the plugins create all of our nodes for us. We also need to make a few tweaks to the \u003ccode\u003ecreatePages\u003c/code\u003e and \u003ccode\u003eonCreateNode\u003c/code\u003e functions.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003egatsby-node.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createFilePath } = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby-source-filesystem\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.createPages = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ graphql, actions }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createPage } = actions;\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e markdownPages = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e graphql(\u003cspan class=\"hljs-string\"\u003e`\n    query {\n      allMarkdownRemark {\n        edges {\n          node {\n            fields {\n              slug\n            }\n          }\n        }\n      }\n    }\n  `\u003c/span\u003e);\n\n  markdownPages.data.allMarkdownRemark.edges.forEach(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e{ node }\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    createPage({\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: node.fields.slug,\n      \u003cspan class=\"hljs-attr\"\u003ecomponent\u003c/span\u003e: \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e.resolve(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;./src/templates/blog-post.js\u0026#x27;\u003c/span\u003e),\n      \u003cspan class=\"hljs-attr\"\u003econtext\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003eslug\u003c/span\u003e: node.fields.slug\n      }\n    });\n  });\n};\n\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.onCreateNode = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e ({ node, getNode, actions }) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e { createNodeField } = actions;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node.internal.type === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;MarkdownRemark\u0026#x27;\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e slug = createFilePath({ node, getNode });\n    createNodeField({\n      node,\n      \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;slug\u0026#x27;\u003c/span\u003e,\n      \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: slug\n    });\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat\u0026#x27;s the whole file now! That really cleans things up doesn\u0026#x27;t it?! 😌 One completely new item is that in \u003ccode\u003eonCreateNode\u003c/code\u003e we have to create our own slug for the MardownRemark nodes. We can actually specify these in the markdown post\u0026#x27;s \u003ca href=\"https://www.gatsbyjs.org/docs/adding-markdown-pages/#frontmatter-for-metadata-in-markdown-files\"\u003efrontmatter\u003c/a\u003e if we wanted to, since MarkdownRemark gives us frontmatter parsing as a free bonus! However, if your file names are going to be consistent with your slugs, you can just create a slug field using the relative file path to make things a bit easier, and it\u0026#x27;s also simplified by \u003ccode\u003egatsby-source-filesystem\u003c/code\u003e as it provides a function to do so.\u003c/p\u003e\u003cp\u003eThe last change we made was to change our \u003ccode\u003eallBlogHtml\u003c/code\u003e node names in the query to \u003ccode\u003eallMarkdownRemark\u003c/code\u003e. It\u0026#x27;s important to note also that since we added the slug as a \u003ccode\u003efield\u003c/code\u003e, you need to access it with \u003ccode\u003enode.fields.slug\u003c/code\u003e rather than just \u003ccode\u003enode.slug\u003c/code\u003e. Finally, we just need to change the node names in our template file.\u003c/p\u003e\u003cdiv class=\"remark-code-title\"\u003esrc/templates/blog-post.js\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { graphql } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;gatsby\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e React \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eBlogPost\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ data }\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e (\n    \u003cspan class=\"xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edangerouslySetInnerHTML\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{{\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003e__html:\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003edata.markdownRemark.html\u003c/span\u003e }}\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// highlight-line\u003c/span\u003e\n  );\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e query = graphql\u003cspan class=\"hljs-string\"\u003e`\n  query($slug: String!) {\n    markdownRemark(fields: { slug: { eq: $slug } }) { // highlight-line\n      html\n    }\n  }\n`\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRestart Gatsby and voila! Everything is exactly as it was before, with 95% less \u003cem\u003ecustom\u003c/em\u003e code. However, we\u0026#x27;ll be wise to note that all of the functionality we just removed from our own \u003ccode\u003egatsby-node.js\u003c/code\u003e is now in each plugin\u0026#x27;s own \u003ccode\u003egatsby-node.js\u003c/code\u003e file.\u003c/p\u003e\u003cp\u003eThat\u0026#x27;s how Gatsby\u0026#x27;s plugin system works. Plugins provide their own functionality by wrapping everything in a tidy package which contains just the Gatsby APIs they utilize. If you \u003ca href=\"https://github.com/gatsbyjs/gatsby/tree/master/packages/gatsby-source-filesystem/src\"\u003eopen the code\u003c/a\u003e for \u003ccode\u003egatsby-source-filesystem\u003c/code\u003e for example, you\u0026#x27;ll see it also has a \u003ccode\u003egatsby-node.js\u003c/code\u003e file which does what we coded ourselves (and much more, of course). When we install the plugin and add it to our configuration, the idea is it \u0026quot;plugs in\u0026quot; to our own project\u0026#x27;s Gatsby build process as though we had the code in our \u003ccode\u003egatsby-node.js\u003c/code\u003e file.\u003c/p\u003e\u003cp\u003eLikewise, if we were to make our own plugin that we wanted to reuse in other projects, or even publish publicly, we could extract the relevant code from our \u003ccode\u003egatsby-node.js\u003c/code\u003e file into a \u003ccode\u003e/plugins/my-plugin\u003c/code\u003e folder with its own \u003ccode\u003epackage.json\u003c/code\u003e and \u003ccode\u003egatsby-node.js\u003c/code\u003e file, and we\u0026#x27;d pretty much be ready to use it. Neat!\u003c/p\u003e\u003cp\u003eI created this post in order to learn Gatsby more deeply as I created this very blog! So, if you\u0026#x27;re interested in seeing the full code as it stands at the end of this post, you can visit the relevant branches in the Github repository. The final version using our custom code is available at the \u003ca href=\"https://github.com/Daynil/quests-in-code/tree/final-plugin-free\"\u003efinal-plugin-free\u003c/a\u003e branch, and the final version after we swapped everything for Gatsby plugins is available at \u003ca href=\"https://github.com/Daynil/quests-in-code/tree/gatsby-plugins\"\u003egatsby-plugins\u003c/a\u003e.\u003c/p\u003e\u003ch2\u003eConclusion\u003c/h2\u003e\u003cp\u003eSo what have we learned from today\u0026#x27;s adventure?\u003c/p\u003e\u003cp\u003eWe took a deep dive into Gatsby\u0026#x27;s internals, and essentially reimplemented basic functioning versions of some of Gatsby\u0026#x27;s popular plugins. Along the way, I think we\u0026#x27;ve certainly developed an appreciation for the complexity that is abstracted away.\u003c/p\u003e\u003cp\u003eHowever, since we didn’t shy away from this complexity initially, we now understand exactly how many of Gatsby\u0026#x27;s key core systems operate, and we\u0026#x27;re well equipped to understand exactly how most plugins operate, as well as how to create our own for custom use cases if needed.\u003c/p\u003e\u003cp\u003eFor me, tools like Gatsby really come alive when you don\u0026#x27;t just take their abstractions for granted, instead diving in head-first and really taking the time to figure out how things work and come together. Once you\u0026#x27;ve developed a robust mental model for the foundational principles, as we have, you can take a step back and leverage the advantages of such a tool.\u003c/p\u003e\u003cp\u003eWell, one might think, if after swapping out our code for Gatsby plugins we ended up with exactly the same thing, what exactly did we gain other than writing less custom code?\u003c/p\u003e\u003cp\u003eAs you may have noticed, our implementations of the plugin were very basic and naïve. We wouldn\u0026#x27;t want to use code like that in production. Many edge cases are not addressed, and we only built it to function exactly how we were currently trying to use it.\u003c/p\u003e\u003cp\u003eRather than having to build production-ready code for every single use case, we can utilize some of Gatsby\u0026#x27;s existing plugins to save us a ton of time and energy, and we get a lot of additional bonuses. You may have noticed, for example, that while it is loading, our cat image now holds its position in the page, and blurs in when we open our \u003ccode\u003elevel-one\u003c/code\u003e blog post. Super cool! These are clearly non-trivial things to accomplish, but we get a robust mechanism for doing them for free with our plugins.\u003c/p\u003e\u003cp\u003eIf we ever run into the limitations of existing plugins, or we need to source data from new places, we now know exactly where to start. In the same spirit as this blog post, if you ever feel you don\u0026#x27;t understand something about a plugin, or it seems not to work right for some reason, don\u0026#x27;t be shy about diving into the plugin\u0026#x27;s codebase. You know how it should work now!\u003c/p\u003e\u003cp\u003eWith that, it\u0026#x27;s onward to new adventures!\u003c/p\u003e","scope":{}},"slug":"gatsby-blog-from-scratch","title":"Gatsby Blog From Scratch: An In-depth Guide to Starting with Gatsby","tags":["JavaScript","React","Gatsby"],"date":"2020-04-17","description":"Building a technical GatsbyJS blog from scratch without plugins for a deeper understanding of Gatsby's core systems."},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"gatsby-blog-from-scratch"},"buildId":"g7013D7AffeHbYIMAFrrP","nextExport":false,"isFallback":false,"gsp":true,"head":[["meta",{"charSet":"utf-8"}],["meta",{"name":"viewport","content":"width=device-width"}]]}</script><script nomodule="" src="/_next/static/chunks/polyfills-555defa4e62ba07d4446.js"></script><script src="/_next/static/chunks/main-c03b5bd9cab9af413ee9.js" async=""></script><script src="/_next/static/chunks/webpack-e067438c4cf4ef2ef178.js" async=""></script><script src="/_next/static/chunks/framework.1daf1ec1ecf144ee9147.js" async=""></script><script src="/_next/static/chunks/3a4420f2.bca366718f045dbe8189.js" async=""></script><script src="/_next/static/chunks/commons.fae3faba8f8bd34b5e08.js" async=""></script><script src="/_next/static/chunks/pages/_app-be96f0ea7c84f952feb5.js" async=""></script><script src="/_next/static/chunks/49fdb156c9f06797842462c7c8894acb798ce899.cb877f7e0fcd4b00a731.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-3d9761e151184b59a336.js" async=""></script><script src="/_next/static/g7013D7AffeHbYIMAFrrP/_buildManifest.js" async=""></script><script src="/_next/static/g7013D7AffeHbYIMAFrrP/_ssgManifest.js" async=""></script></body></html>